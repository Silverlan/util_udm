// GENERATED by merge_cppm.py on 2025-12-13T20:29:56.252214 // UTC
// Merged 24 partition files

module;

#include "definitions.hpp"
#include <cassert>
#include "util_enum_flags.hpp"

export module pragma.udm;

export import pragma.filesystem;
export import pragma.math;
export import pragma.util;
export import std.compat;

// --- BEGIN PARTITION: src/interface/basic_types.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:basic_types;

export import pragma.math;
*/

// --- START BODY: src/interface/basic_types.cppm ---

export {
	namespace udm {
		using DataValue = void *;
		using String = std::string;
		using Int8 = int8_t;
		using UInt8 = uint8_t;
		using Int16 = int16_t;
		using UInt16 = uint16_t;
		using Int32 = int32_t;
		using UInt32 = uint32_t;
		using Int64 = int64_t;
		using UInt64 = uint64_t;
		using Enum = int32_t;
		using Float = float;
		using Double = double;
		using Boolean = bool;

		using Vector2 = Vector2;
		using Vector3 = Vector3;
		using Vector4 = Vector4;
		using Vector2i = Vector2i;
		using Vector3i = Vector3i;
		using Vector4i = Vector4i;
		using Quaternion = Quat;
		using EulerAngles = EulerAngles;
		using Srgba = std::array<uint8_t, 4>;
		using HdrColor = std::array<uint16_t, 3>;
		using Transform = pragma::math::Transform;
		using ScaledTransform = pragma::math::ScaledTransform;
		using Mat4 = Mat4;
		using Mat3x4 = Mat3x4;
		using Nil = std::monostate;
	};
}

// --- END PARTITION: src/interface/basic_types.cppm ---

// --- BEGIN PARTITION: src/interface/core.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"
#include <cassert>

export module pragma.udm:core;

export import std.compat;
*/

// --- START BODY: src/interface/core.cppm ---

#undef VERSION

export {
	namespace udm {
		using Version = uint32_t;
		/* Version history:
		* 1: Initial version
		* 2: Added types: reference, arrayLz4, struct, half, vector2i, vector3i, vector4i
		*/
		constexpr Version VERSION = 2;
		constexpr auto *HEADER_IDENTIFIER = "UDMB";
#pragma pack(push, 1)
		struct DLLUDM Header {
			Header() = default;
			std::array<char, 4> identifier = {HEADER_IDENTIFIER[0], HEADER_IDENTIFIER[1], HEADER_IDENTIFIER[2], HEADER_IDENTIFIER[3]};
			Version version = VERSION;
		};
#pragma pack(pop)

		namespace detail {
			DLLUDM void test_c_wrapper();
		};
	};
}

// --- END PARTITION: src/interface/core.cppm ---

// --- BEGIN PARTITION: src/interface/enums.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"
#include "util_enum_flags.hpp"

export module pragma.udm:enums;

import pragma.util;
*/

// --- START BODY: src/interface/enums.cppm ---

export {
	namespace udm {
		enum class Type : uint8_t {
			Nil = 0,
			String,
			Utf8String,

			Int8,
			UInt8,
			Int16,
			UInt16,
			Int32,
			UInt32,
			Int64,
			UInt64,

			Float,
			Double,
			Boolean,

			Vector2,
			Vector3,
			Vector4,
			Quaternion,
			EulerAngles,
			Srgba,
			HdrColor,
			Transform,
			ScaledTransform,
			Mat4,
			Mat3x4,

			Blob,
			BlobLz4,

			Element,
			Array,
			ArrayLz4,
			Reference,
			Struct,
			Half,
			Vector2i,
			Vector3i,
			Vector4i,

			Count,
			Last = Count - 1,
			Invalid = std::numeric_limits<uint8_t>::max()
		};

		enum class ArrayType : uint8_t {
			Raw = 0,
			Compressed,
		};

		enum class BlobResult : uint8_t {
			Success = 0,
			DecompressedSizeMismatch,
			InsufficientSize,
			ValueTypeMismatch,
			NotABlobType,
			InvalidProperty,
		};

		enum class MergeFlags : uint32_t {
			None = 0u,
			OverwriteExisting = 1u,
			DeepCopy = OverwriteExisting << 1u,
		};

		enum class FormatType : uint8_t {
			Binary = 0,
			Ascii,
		};

		enum class AsciiSaveFlags : uint32_t {
			None = 0u,
			IncludeHeader = 1u,
			DontCompressLz4Arrays = IncludeHeader << 1u,
			Default = None,
		};

		constexpr const char *enum_type_to_ascii(Type t)
		{
			// Note: These have to match ascii_type_to_enum
			switch(t) {
			case Type::Nil:
				return "nil";
			case Type::String:
				return "string";
			case Type::Utf8String:
				return "utf8";
			case Type::Int8:
				return "int8";
			case Type::UInt8:
				return "uint8";
			case Type::Int16:
				return "int16";
			case Type::UInt16:
				return "uint16";
			case Type::Int32:
				return "int32";
			case Type::UInt32:
				return "uint32";
			case Type::Int64:
				return "int64";
			case Type::UInt64:
				return "uint64";
			case Type::Float:
				return "float";
			case Type::Double:
				return "double";
			case Type::Boolean:
				return "bool";
			case Type::Vector2:
				return "vec2";
			case Type::Vector2i:
				return "vec2i";
			case Type::Vector3:
				return "vec3";
			case Type::Vector3i:
				return "vec3i";
			case Type::Vector4:
				return "vec4";
			case Type::Vector4i:
				return "vec4i";
			case Type::Quaternion:
				return "quat";
			case Type::EulerAngles:
				return "ang";
			case Type::Srgba:
				return "srgba";
			case Type::HdrColor:
				return "hdr";
			case Type::Transform:
				return "transform";
			case Type::ScaledTransform:
				return "stransform";
			case Type::Mat4:
				return "mat4";
			case Type::Mat3x4:
				return "mat3x4";
			case Type::Blob:
				return "blob";
			case Type::BlobLz4:
				return "lz4";
			case Type::Array:
				return "array";
			case Type::ArrayLz4:
				return "arrayLz4";
			case Type::Element:
				return "element";
			case Type::Reference:
				return "ref";
			case Type::Half:
				return "half";
			case Type::Struct:
				return "struct";
			default:
				break;
			}
			static_assert(pragma::math::to_integral(Type::Count) == 36, "Update this list when new types are added!");
			return nullptr;
		}
		DLLUDM Type ascii_type_to_enum(const std::string_view &type);

		template<typename TEnum>
		constexpr std::string_view enum_to_string(TEnum e)
		{
			return magic_enum::enum_name(e);
		}

		template<typename TEnum>
		constexpr std::string flags_to_string(TEnum e)
		{
			return magic_enum::enum_flags_name(e);
		}

		using namespace pragma::math::scoped_enum::bitwise;
	};

	REGISTER_ENUM_FLAGS(udm::AsciiSaveFlags)
	REGISTER_ENUM_FLAGS(udm::MergeFlags)
}

// --- END PARTITION: src/interface/enums.cppm ---

// --- BEGIN PARTITION: src/interface/exception.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:exception;

export import std.compat;
*/

// --- START BODY: src/interface/exception.cppm ---

export {
	namespace udm {
		struct DLLUDM Exception : public std::runtime_error {
			Exception(const std::string &msg) : std::runtime_error {msg.c_str()}, m_msg {msg} {}
		  private:
			std::string m_msg;
		};

		struct DLLUDM InvalidUsageError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM CompressionError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM FileError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM InvalidFormatError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM PropertyLoadError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM OutOfBoundsError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM ImplementationError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM LogicError : public Exception {
			using Exception::Exception;
		};
		struct DLLUDM ComparisonError : public Exception {
			using Exception::Exception;
		};

		struct DLLUDM AsciiException : public Exception {
			AsciiException(const std::string &msg, uint32_t lineIdx, uint32_t charIdx);
			uint32_t lineIndex = 0;
			uint32_t charIndex = 0;
		};

		struct DLLUDM SyntaxError : public AsciiException {
			using AsciiException::AsciiException;
		};
		struct DLLUDM DataError : public AsciiException {
			using AsciiException::AsciiException;
		};
	};
}

// --- END PARTITION: src/interface/exception.cppm ---

// --- BEGIN PARTITION: src/interface/file.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:file;

export import pragma.filesystem;
*/

// --- START BODY: src/interface/file.cppm ---

export {
	namespace udm {
		using IFile = ufile::IFile;
		using MemoryFile = ufile::MemoryFile;
		using VectorFile = ufile::VectorFile;
	};
}

// --- END PARTITION: src/interface/file.cppm ---

// --- BEGIN PARTITION: src/interface/half.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:half;

export import std.compat;
*/

// --- START BODY: src/interface/half.cppm ---

export {
	namespace udm {
#pragma pack(push, 1)
		struct DLLUDM Half {
			Half() = default;
			Half(uint16_t value) : value {value} {}
			Half(const Half &other) = default;
			Half(float value);
			operator float() const;
			Half &operator=(float value);
			Half &operator=(uint16_t value);
			Half &operator=(const Half &other) = default;
			uint16_t value;
		};
#pragma pack(pop)
		static_assert(sizeof(Half) == sizeof(uint16_t));
	};
}

// --- END PARTITION: src/interface/half.cppm ---

// --- BEGIN PARTITION: src/interface/types.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:types;

export import std.compat;
*/

// --- START BODY: src/interface/types.cppm ---

export {
	namespace udm {
		struct Half;
		struct Exception;
		struct InvalidUsageError;
		struct CompressionError;
		struct FileError;
		struct InvalidFormatError;
		struct PropertyLoadError;
		struct OutOfBoundsError;
		struct ImplementationError;
		struct LogicError;
		struct ComparisonError;
		struct AsciiException;
		struct SyntaxError;
		struct DataError;
		struct Blob;
		struct BlobLz4;
		struct Utf8String;
		enum class Type : uint8_t;
		enum class ArrayType : uint8_t;
		enum class BlobResult : uint8_t;
		enum class MergeFlags : uint32_t;
		enum class AsciiSaveFlags : uint32_t;
		struct LinkedPropertyWrapper;
		using LinkedPropertyWrapperArg = const LinkedPropertyWrapper &;
		struct Array;
		struct StructDescription;
		struct Property;
		using PProperty = std::shared_ptr<Property>;
		using WPProperty = std::weak_ptr<Property>;
		struct Property;
		struct Header;
		struct PropertyWrapper;
		class ElementIterator;
		struct ElementIteratorWrapper;
		class Data;
		struct Reference;
		struct Struct;
		struct Element;
		struct ElementIteratorPair;
		class AsciiReader;
		struct ArrayLz4;
		struct AssetData;
		using AssetDataArg = const AssetData &;
		enum class FormatType : uint8_t;
		enum class AsciiSaveFlags : uint32_t;
		class Data;
		using Hash = std::array<uint8_t, sizeof(uint32_t) * 4>;
	};
}

// --- END PARTITION: src/interface/types.cppm ---

// --- BEGIN PARTITION: src/interface/blob.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:types.blob;

import :exception;
*/

// --- START BODY: src/interface/blob.cppm ---

export {
	namespace udm {
		struct DLLUDM Blob {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			Blob() = default;
			Blob(const Blob &) = default;
			Blob(Blob &&) = default;
			Blob(std::vector<uint8_t> &&data) : data {data} {}
			std::vector<uint8_t> data;

			Blob &operator=(Blob &&other);
			Blob &operator=(const Blob &other);

			bool operator==(const Blob &other) const
			{
				auto res = (data == other.data);
				UDM_ASSERT_COMPARISON(res);
				return res;
			}
			bool operator!=(const Blob &other) const { return !operator==(other); }
		};

		struct DLLUDM BlobLz4 {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			BlobLz4() = default;
			BlobLz4(const BlobLz4 &) = default;
			BlobLz4(BlobLz4 &&) = default;
			BlobLz4(std::vector<uint8_t> &&compressedData, size_t uncompressedSize) : compressedData {compressedData}, uncompressedSize {uncompressedSize} {}
			size_t uncompressedSize = 0;
			std::vector<uint8_t> compressedData;

			BlobLz4 &operator=(BlobLz4 &&other);
			BlobLz4 &operator=(const BlobLz4 &other);

			bool operator==(const BlobLz4 &other) const
			{
				auto res = (uncompressedSize == other.uncompressedSize && compressedData == other.compressedData);
				UDM_ASSERT_COMPARISON(res);
				return res;
			}
			bool operator!=(const BlobLz4 &other) const { return !operator==(other); }
		};

		DLLUDM Blob decompress_lz4_blob(const BlobLz4 &data);
		DLLUDM Blob decompress_lz4_blob(const void *compressedData, uint64_t compressedSize, uint64_t uncompressedSize);
		DLLUDM void decompress_lz4_blob(const void *compressedData, uint64_t compressedSize, uint64_t uncompressedSize, void *outData);
		DLLUDM BlobLz4 compress_lz4_blob(const Blob &data);
		DLLUDM BlobLz4 compress_lz4_blob(const void *data, uint64_t size);
		template<class T>
		BlobLz4 compress_lz4_blob(const T &v)
		{
			return compress_lz4_blob(v.data(), v.size() * sizeof(v[0]));
		}
	}
}

// --- END PARTITION: src/interface/blob.cppm ---

// --- BEGIN PARTITION: src/interface/reference.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:reference;

export import :exception;
export import :types;
*/

// --- START BODY: src/interface/reference.cppm ---

export {
	namespace udm {
		struct DLLUDM Reference {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			Reference() = default;
			Reference(const std::string &path) : path {path} {}
			Reference(const Reference &other) : property {other.property}, path {other.path} {}
			Reference(Reference &&other) : property {other.property}, path {std::move(other.path)} {}
			Property *property = nullptr;
			std::string path;

			Reference &operator=(Reference &&other);
			Reference &operator=(const Reference &other);

			bool operator==(const Reference &other) const
			{
				auto res = (property == other.property);
				UDM_ASSERT_COMPARISON(res);
				return res;
			}
			bool operator!=(const Reference &other) const { return !operator==(other); }
		  private:
			friend Data;
			void InitializeProperty(const LinkedPropertyWrapper &root);
		};
	}
}

// --- END PARTITION: src/interface/reference.cppm ---

// --- BEGIN PARTITION: src/interface/string.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:types.string;

import :exception;
*/

// --- START BODY: src/interface/string.cppm ---

export {
	namespace udm {
		struct DLLUDM Utf8String {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			Utf8String() = default;
			Utf8String(std::vector<uint8_t> &&data) : data {data} {}
			Utf8String(const Utf8String &str) : data {str.data} {}
			std::vector<uint8_t> data;

			Utf8String &operator=(Utf8String &&other);
			Utf8String &operator=(const Utf8String &other);

			bool operator==(const Utf8String &other) const
			{
				auto res = (data == other.data);
				UDM_ASSERT_COMPARISON(res);
				return res;
			}
			bool operator!=(const Utf8String &other) const { return !operator==(other); }
		};
	}
}

// --- END PARTITION: src/interface/string.cppm ---

// --- BEGIN PARTITION: src/interface/trivial_types.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:trivial_types;

export import :basic_types;
export import :enums;
export import :exception;
export import :half;
export import :types;
import pragma.util;
*/

// --- START BODY: src/interface/trivial_types.cppm ---

export {
#ifdef __linux__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wreturn-type"
#pragma GCC diagnostic ignored "-Wswitch"
#elif _WIN32
#pragma warning(push)
#pragma warning(disable : 4715)
#endif
	namespace udm {
		constexpr std::array<Type, 12> NUMERIC_TYPES = {Type::Int8, Type::UInt8, Type::Int16, Type::UInt16, Type::Int32, Type::UInt32, Type::Int64, Type::UInt64, Type::Float, Type::Double, Type::Boolean, Type::Half};
		constexpr std::array<Type, 15> GENERIC_TYPES
		  = {Type::Vector2, Type::Vector3, Type::Vector4, Type::Vector2i, Type::Vector3i, Type::Vector4i, Type::Quaternion, Type::EulerAngles, Type::Srgba, Type::HdrColor, Type::Transform, Type::ScaledTransform, Type::Mat4, Type::Mat3x4, Type::Nil};
		constexpr std::array<Type, 9> NON_TRIVIAL_TYPES = {Type::String, Type::Utf8String, Type::Blob, Type::BlobLz4, Type::Element, Type::Array, Type::ArrayLz4, Type::Reference, Type::Struct};

		template<typename T>
		concept is_vector_type = std::is_same_v<T, Vector2> || std::is_same_v<T, Vector2i> || std::is_same_v<T, Vector3> || std::is_same_v<T, Vector3i> || std::is_same_v<T, Vector4> || std::is_same_v<T, Vector4i>;
		template<typename T>
		concept is_integral_vector_type = std::is_same_v<T, Vector2i> || std::is_same_v<T, Vector3i> || std::is_same_v<T, Vector4i>;
		template<typename T>
		concept is_matrix_type = std::is_same_v<T, Mat4> || std::is_same_v<T, Mat3x4>;
		template<typename T>
		concept is_arithmetic = std::is_arithmetic_v<T> || std::is_same_v<T, Half>;

		template<typename T>
		using underlying_numeric_type = std::conditional_t<std::is_same_v<T, Half>, uint16_t,
		  std::conditional_t<is_arithmetic<T>, T,
		    std::conditional_t<is_integral_vector_type<T>, Vector3i::value_type,
		      std::conditional_t<is_vector_type<T> || is_matrix_type<T> || std::is_same_v<T, Quaternion>, float,
		        std::conditional_t<std::is_same_v<T, Srgba>, uint8_t, std::conditional_t<std::is_same_v<T, HdrColor>, uint16_t, std::conditional_t<std::is_same_v<T, EulerAngles>, float, void>>>>>>>;

		template<typename T>
		constexpr Type type_to_enum();
		template<typename T>
		constexpr Type type_to_enum_s();
		template<typename T>
		constexpr bool is_udm_type()
		{
			return type_to_enum_s<T>() != Type::Invalid;
		}

		constexpr size_t size_of(Type t);
		template<typename T>
		constexpr Type array_value_type_to_enum();

		constexpr bool is_numeric_type(Type t)
		{
			switch(t) {
			case Type::Int8:
			case Type::UInt8:
			case Type::Int16:
			case Type::UInt16:
			case Type::Int32:
			case Type::UInt32:
			case Type::Int64:
			case Type::UInt64:
			case Type::Float:
			case Type::Double:
			case Type::Boolean:
			case Type::Half:
				return true;
			}
			return false;
		}

		constexpr bool is_generic_type(Type t)
		{
			switch(t) {
			case Type::Vector2:
			case Type::Vector3:
			case Type::Vector4:
			case Type::Vector2i:
			case Type::Vector3i:
			case Type::Vector4i:
			case Type::Quaternion:
			case Type::EulerAngles:
			case Type::Srgba:
			case Type::HdrColor:
			case Type::Transform:
			case Type::ScaledTransform:
			case Type::Mat4:
			case Type::Mat3x4:
			case Type::Nil:
				return true;
			}
			return false;
		}

		constexpr uint8_t get_numeric_component_count(Type type)
		{
			if(is_numeric_type(type))
				return 1;
			switch(type) {
			case Type::Vector2:
			case Type::Vector2i:
				return 2;
			case Type::Vector3:
			case Type::Vector3i:
			case Type::EulerAngles:
			case Type::HdrColor:
				return 3;
			case Type::Vector4:
			case Type::Vector4i:
			case Type::Quaternion:
			case Type::Srgba:
				return 4;
			case Type::Transform:
				return 7;
			case Type::ScaledTransform:
				return 10;
			case Type::Mat3x4:
				return 12;
			case Type::Mat4:
				return 16;
			}
			return 0;
		}

		template<typename T>
		underlying_numeric_type<T> &get_numeric_component(T &value, uint8_t idx)
		{
			if constexpr(std::is_same_v<T, Half>)
				return value.value;
			else if constexpr(udm::is_arithmetic<T>)
				return value;
			else if constexpr(udm::is_vector_type<T> || std::is_same_v<T, EulerAngles> || std::is_same_v<T, Srgba> || std::is_same_v<T, HdrColor>)
				return value[idx];
			else if constexpr(std::is_same_v<T, Quaternion>) {
				// Quaternion memory order is xyzw, but we want wxyz
				if(idx == 0)
					return value[3];
				return value[idx - 1];
			}
			else {
				static_assert(std::is_same_v<underlying_numeric_type<T>, float>);
				return *(reinterpret_cast<float *>(&value) + idx);
			}
		}

		template<typename T>
		const underlying_numeric_type<T> &get_numeric_component(const T &value, uint8_t idx)
		{
			return get_numeric_component<T>(const_cast<T &>(value), idx);
		}

		template<typename T>
		void set_numeric_component(T &value, uint8_t idx, const underlying_numeric_type<T> &compVal)
		{
			if constexpr(std::is_same_v<T, Half>)
				value.value = compVal;
			else if constexpr(udm::is_arithmetic<T>)
				value = compVal;
			else if constexpr(udm::is_vector_type<T> || std::is_same_v<T, EulerAngles> || std::is_same_v<T, Srgba> || std::is_same_v<T, HdrColor>)
				value[idx] = compVal;
			else if constexpr(std::is_same_v<T, Quaternion>) {
				// Quaternion memory order is xyzw, but we want wxyz
				if(idx == 0)
					value[3] = compVal;
				else
					value[idx - 1] = compVal;
			}
			else {
				static_assert(std::is_same_v<underlying_numeric_type<T>, float>);
				*(reinterpret_cast<float *>(&value) + idx) = compVal;
			}
		}

		constexpr bool is_non_trivial_type(Type t)
		{
			switch(t) {
			case Type::String:
			case Type::Utf8String:
			case Type::Blob:
			case Type::BlobLz4:
			case Type::Element:
			case Type::Array:
			case Type::ArrayLz4:
			case Type::Reference:
			case Type::Struct:
				return true;
			}
			static_assert(NON_TRIVIAL_TYPES.size() == 9, "Update this list when new non-trivial types have been added!");
			return false;
		}

		constexpr bool is_common_type(Type t) { return is_numeric_type(t) || is_generic_type(t) || t == Type::String; }

		template<bool ENABLE_NUMERIC = true, bool ENABLE_GENERIC = true, bool ENABLE_NON_TRIVIAL = true>
		constexpr bool is_type(Type type)
		{
			if constexpr(ENABLE_NUMERIC) {
				if(is_numeric_type(type))
					return true;
			}
			if constexpr(ENABLE_GENERIC) {
				if(is_generic_type(type))
					return true;
			}
			if constexpr(ENABLE_NON_TRIVIAL) {
				if(is_non_trivial_type(type))
					return true;
			}
			return false;
		}
		constexpr bool is_ng_type(Type type) { return is_type<true, true, false>(type); }
		constexpr bool is_gnt_type(Type type) { return is_type<false, true, true>(type); }

		constexpr bool is_array_type(Type t)
		{
			switch(t) {
			case Type::Array:
			case Type::ArrayLz4:
				return true;
			}
			return false;
		}

		constexpr bool is_trivial_type(Type t) { return !is_non_trivial_type(t) && t != Type::Invalid; }

		template<class T>
		struct tag_t {
			using type = T;
		};
		template<class T>
		constexpr tag_t<T> tag = {};
		constexpr std::variant<tag_t<Int8>, tag_t<UInt8>, tag_t<Int16>, tag_t<UInt16>, tag_t<Int32>, tag_t<UInt32>, tag_t<Int64>, tag_t<UInt64>, tag_t<Float>, tag_t<Double>, tag_t<Boolean>, tag_t<Half>> get_numeric_tag(Type e)
		{
			switch(e) {
			case Type::Int8:
				return tag<Int8>;
			case Type::UInt8:
				return tag<UInt8>;
			case Type::Int16:
				return tag<Int16>;
			case Type::UInt16:
				return tag<UInt16>;
			case Type::Int32:
				return tag<Int32>;
			case Type::UInt32:
				return tag<UInt32>;
			case Type::Int64:
				return tag<Int64>;
			case Type::UInt64:
				return tag<UInt64>;
			case Type::Float:
				return tag<Float>;
			case Type::Double:
				return tag<Double>;
			case Type::Boolean:
				return tag<Boolean>;
			case Type::Half:
				return tag<Half>;
			}
		}

		constexpr std::variant<tag_t<Vector2>, tag_t<Vector3>, tag_t<Vector4>, tag_t<Vector2i>, tag_t<Vector3i>, tag_t<Vector4i>, tag_t<Quaternion>, tag_t<EulerAngles>, tag_t<Srgba>, tag_t<HdrColor>, tag_t<Transform>, tag_t<ScaledTransform>, tag_t<Mat4>, tag_t<Mat3x4>, tag_t<Nil>>
		get_generic_tag(Type e)
		{
			switch(e) {
			case Type::Vector2:
				return tag<Vector2>;
			case Type::Vector3:
				return tag<Vector3>;
			case Type::Vector4:
				return tag<Vector4>;
			case Type::Vector2i:
				return tag<Vector2i>;
			case Type::Vector3i:
				return tag<Vector3i>;
			case Type::Vector4i:
				return tag<Vector4i>;
			case Type::Quaternion:
				return tag<Quaternion>;
			case Type::EulerAngles:
				return tag<EulerAngles>;
			case Type::Srgba:
				return tag<Srgba>;
			case Type::HdrColor:
				return tag<HdrColor>;
			case Type::Transform:
				return tag<Transform>;
			case Type::ScaledTransform:
				return tag<ScaledTransform>;
			case Type::Mat4:
				return tag<Mat4>;
			case Type::Mat3x4:
				return tag<Mat3x4>;
			case Type::Nil:
				return tag<Nil>;
			}
		}

		constexpr std::variant<tag_t<String>> get_common_tag_exclusive(Type e)
		{
			switch(e) {
			case Type::String:
				return tag<String>;
			}
		}

		struct Element;
		struct Array;
		struct ArrayLz4;
		struct Reference;
		struct Struct;
		constexpr std::variant<tag_t<String>, tag_t<Utf8String>, tag_t<Blob>, tag_t<BlobLz4>, tag_t<Element>, tag_t<Array>, tag_t<ArrayLz4>, tag_t<Reference>, tag_t<Struct>> get_non_trivial_tag(Type e)
		{
			switch(e) {
			case Type::String:
				return tag<String>;
			case Type::Utf8String:
				return tag<Utf8String>;
			case Type::Blob:
				return tag<Blob>;
			case Type::BlobLz4:
				return tag<BlobLz4>;
			case Type::Element:
				return tag<Element>;
			case Type::Array:
				return tag<Array>;
			case Type::ArrayLz4:
				return tag<ArrayLz4>;
			case Type::Reference:
				return tag<Reference>;
			case Type::Struct:
				return tag<Struct>;
			}
			static_assert(NON_TRIVIAL_TYPES.size() == 9, "Update this list when new non-trivial types have been added!");
		}
		template<bool ENABLE_NUMERIC = true, bool ENABLE_GENERIC = true, bool ENABLE_NON_TRIVIAL = true, bool ENABLE_DEFAULT_RETURN = true, typename T>
		    requires(ENABLE_NUMERIC || ENABLE_GENERIC || ENABLE_NON_TRIVIAL)
		constexpr decltype(auto) visit(Type type, T vs)
		{
			if constexpr(ENABLE_NUMERIC) {
				if(is_numeric_type(type))
					return std::visit(vs, get_numeric_tag(type));
			}
			if constexpr(ENABLE_GENERIC) {
				if(is_generic_type(type))
					return std::visit(vs, get_generic_tag(type));
			}
			if constexpr(ENABLE_NON_TRIVIAL) {
				if(is_non_trivial_type(type))
					return std::visit(vs, get_non_trivial_tag(type));
			}
			// Unreachable if all template types enabled

			// Failure case, return default value
			if constexpr(ENABLE_DEFAULT_RETURN && (!ENABLE_NUMERIC || !ENABLE_GENERIC || !ENABLE_NON_TRIVIAL)) {
				if constexpr(ENABLE_NUMERIC) {
					if(is_numeric_type(type))
						return decltype(std::visit(vs, get_numeric_tag(type)))();
				}
				if constexpr(ENABLE_GENERIC) {
					if(is_generic_type(type))
						return decltype(std::visit(vs, get_generic_tag(type)))();
				}
				if constexpr(ENABLE_NON_TRIVIAL) {
					if(is_non_trivial_type(type))
						return decltype(std::visit(vs, get_non_trivial_tag(type)))();
				}
			}
		}
		template<bool ENABLE_DEFAULT_RETURN = true>
		constexpr decltype(auto) visit_ng(Type type, auto vs)
		{
			return visit<true, true, false, ENABLE_DEFAULT_RETURN>(type, vs);
		}
		template<bool ENABLE_DEFAULT_RETURN = true>
		constexpr decltype(auto) visit_gnt(Type type, auto vs)
		{
			return visit<false, true, true, ENABLE_DEFAULT_RETURN>(type, vs);
		}
		template<bool ENABLE_DEFAULT_RETURN = true, typename T>
		constexpr decltype(auto) visit_c(Type type, T vs)
		{
			if(is_numeric_type(type))
				return std::visit(vs, get_numeric_tag(type));
			else if(is_generic_type(type))
				return std::visit(vs, get_generic_tag(type));
			else if(is_common_type(type))
				return std::visit(vs, get_common_tag_exclusive(type));

			if constexpr(ENABLE_DEFAULT_RETURN) {
				if(is_numeric_type(type))
					return decltype(std::visit(vs, get_numeric_tag(type)))();
				else if(is_generic_type(type))
					return decltype(std::visit(vs, get_generic_tag(type)))();
				else if(is_common_type(type))
					return decltype(std::visit(vs, get_common_tag_exclusive(type)))();
			}
		}
	};

	template<typename T>
	constexpr udm::Type udm::type_to_enum()
	{
		constexpr auto type = type_to_enum_s<T>();
		if constexpr(pragma::math::to_integral(type) > pragma::math::to_integral(Type::Last))
			[]<bool flag = false>() { static_assert(flag, "Unsupported type!"); }();
		return type;
	}

	template<typename TT>
	constexpr udm::Type udm::type_to_enum_s()
	{
		using T = std::remove_cv_t<std::remove_reference_t<TT>>;
		if constexpr(std::is_enum_v<T>)
			return type_to_enum_s<std::underlying_type_t<T>>();
		if constexpr(pragma::util::is_specialization<T, std::vector>::value)
			return Type::Array;
		else if constexpr(pragma::util::is_specialization<T, std::unordered_map>::value || pragma::util::is_specialization<T, std::map>::value)
			return Type::Element;
		else if constexpr(std::is_same_v<T, Nil> || std::is_same_v<T, void>)
			return Type::Nil;
		else if constexpr(pragma::util::is_string<T>::value || std::is_same_v<T, std::string_view>)
			return Type::String;
		else if constexpr(std::is_same_v<T, Utf8String>)
			return Type::Utf8String;
		else if constexpr(std::is_same_v<T, Int8>)
			return Type::Int8;
		else if constexpr(std::is_same_v<T, UInt8>)
			return Type::UInt8;
		else if constexpr(std::is_same_v<T, Int16>)
			return Type::Int16;
		else if constexpr(std::is_same_v<T, UInt16>)
			return Type::UInt16;
		else if constexpr(std::is_same_v<T, Int32>)
			return Type::Int32;
		else if constexpr(std::is_same_v<T, UInt32>)
			return Type::UInt32;
		else if constexpr(std::is_same_v<T, Int64>)
			return Type::Int64;
		else if constexpr(std::is_same_v<T, UInt64>)
			return Type::UInt64;
		else if constexpr(std::is_same_v<T, Float>)
			return Type::Float;
		else if constexpr(std::is_same_v<T, Double>)
			return Type::Double;
		else if constexpr(std::is_same_v<T, Vector2>)
			return Type::Vector2;
		else if constexpr(std::is_same_v<T, Vector2i>)
			return Type::Vector2i;
		else if constexpr(std::is_same_v<T, Vector3>)
			return Type::Vector3;
		else if constexpr(std::is_same_v<T, Vector3i>)
			return Type::Vector3i;
		else if constexpr(std::is_same_v<T, Vector4>)
			return Type::Vector4;
		else if constexpr(std::is_same_v<T, Vector4i>)
			return Type::Vector4i;
		else if constexpr(std::is_same_v<T, Quaternion>)
			return Type::Quaternion;
		else if constexpr(std::is_same_v<T, EulerAngles>)
			return Type::EulerAngles;
		else if constexpr(std::is_same_v<T, Srgba>)
			return Type::Srgba;
		else if constexpr(std::is_same_v<T, HdrColor>)
			return Type::HdrColor;
		else if constexpr(std::is_same_v<T, Boolean>)
			return Type::Boolean;
		else if constexpr(std::is_same_v<T, Transform>)
			return Type::Transform;
		else if constexpr(std::is_same_v<T, ScaledTransform>)
			return Type::ScaledTransform;
		else if constexpr(std::is_same_v<T, Mat4>)
			return Type::Mat4;
		else if constexpr(std::is_same_v<T, Mat3x4>)
			return Type::Mat3x4;
		else if constexpr(std::is_same_v<T, Blob>)
			return Type::Blob;
		else if constexpr(std::is_same_v<T, BlobLz4>)
			return Type::BlobLz4;
		else if constexpr(std::is_same_v<T, Element>)
			return Type::Element;
		else if constexpr(std::is_same_v<T, Array>)
			return Type::Array;
		else if constexpr(std::is_same_v<T, ArrayLz4>)
			return Type::ArrayLz4;
		else if constexpr(std::is_same_v<T, Reference>)
			return Type::Reference;
		else if constexpr(std::is_same_v<T, Half>)
			return Type::Half;
		else if constexpr(std::is_same_v<T, Struct>)
			return Type::Struct;
		static_assert(pragma::math::to_integral(Type::Count) == 36, "Update this list when new types are added!");
		return Type::Invalid;
	}

	constexpr size_t udm::size_of(Type t)
	{
		if(is_numeric_type(t)) {
			auto tag = get_numeric_tag(t);
			return std::visit([&](auto tag) { return sizeof(typename decltype(tag)::type); }, tag);
		}

		if(is_generic_type(t)) {
			auto tag = get_generic_tag(t);
			return std::visit(
			  [&](auto tag) {
				  if constexpr(std::is_same_v<typename decltype(tag)::type, std::monostate>)
					  return static_cast<uint64_t>(0);
				  return sizeof(typename decltype(tag)::type);
			  },
			  tag);
		}
		throw InvalidUsageError {std::string {"UDM type "} + std::string {magic_enum::enum_name(t)} + " has non-constant size!"};
		static_assert(pragma::math::to_integral(Type::Count) == 36, "Update this list when new types are added!");
		return 0;
	}

	template<typename T>
	constexpr udm::Type udm::array_value_type_to_enum()
	{
		static_assert(pragma::util::is_specialization<T, std::vector>::value);
		return udm::type_to_enum<T::value_type>();
	}

#ifdef __linux__
#pragma GCC diagnostic pop
#elif _WIN32
#pragma warning(pop)
#endif
}

// --- END PARTITION: src/interface/trivial_types.cppm ---

// --- BEGIN PARTITION: src/interface/conversion.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:conversion;

import :reference;
export import :trivial_types;
*/

// --- START BODY: src/interface/conversion.cppm ---

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable : 4715)
#elif defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wswitch"
#endif

export {
	namespace udm {
		template<typename T>
		using base_type = typename std::remove_cv_t<std::remove_pointer_t<std::remove_reference_t<T>>>;
		namespace detail {
			void test_conversions();
			inline uint32_t translate_quaternion_index(uint32_t idx) { return (idx == 0) ? 3 : (idx - 1); }

			template<typename T0, typename T1>
			struct TypeConverter {
				static constexpr auto is_convertible = false;
			};

			template<typename T0, typename T1>
			    requires((!std::is_same_v<T0, String> || std::is_same_v<T1, String> || std::is_same_v<T1, Reference>) && std::is_constructible_v<T1, T0> && !std::is_same_v<T1, Srgba> && !std::is_same_v<T1, HdrColor>)
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					if constexpr(std::is_same_v<T0, Quat> && std::is_same_v<T1, Mat4>)
						return umat::create(v0);
					else
						return T1(v0);
				}
			};

			template<typename T0, typename T1>
			    requires(std::is_same_v<T0, String> && (is_numeric_type(type_to_enum<T1>()) || is_generic_type(type_to_enum<T1>()) || std::is_same_v<T1, Utf8String>) && !std::is_same_v<T1, Nil>)
			struct TypeConverter<T0, T1> {
				template<typename T, typename TValue, uint32_t TCount, uint32_t (*TTranslateIdx)(uint32_t) = nullptr>
				static void parse_value_list(const String &s, T &out)
				{
					size_t startPos = std::numeric_limits<size_t>::max();
					uint32_t idx = 0;
					size_t cIdx = 0;
					auto len = s.length();
					while(idx < TCount) {
						while(cIdx < len && std::isspace(s[cIdx]))
							++cIdx;
						auto start = cIdx;
						while(cIdx < len && !std::isspace(s[cIdx]))
							++cIdx;
						TValue *p;
						if constexpr(TTranslateIdx == nullptr) {
							if constexpr(std::is_same_v<T, Mat4> || std::is_same_v<T, Mat3x4>)
								p = &out[idx / 4][idx % 4];
							else
								p = &out[idx];
						}
						else
							p = &out[TTranslateIdx(idx)];
						*p = {};
						std::from_chars(s.data() + start, s.data() + cIdx, *p);
						++idx;
					}
				}

				static constexpr auto is_convertible = true;
				static T1 convert(const String &v0)
				{
					if constexpr(std::is_same_v<T1, bool>) {
						if(v0 == "1" || v0 == "true")
							return true;
						if(v0 == "0" || v0 == "false")
							return false;
						return false;
					}
					else if constexpr(std::is_same_v<T1, Half>) {
						return Half {pragma::string::to_float(v0)};
					}
					else if constexpr(is_arithmetic<T1>) {
						T1 v1 {};
						std::from_chars(v0.data(), v0.data() + v0.size(), v1);
						return v1;
					}
					else if constexpr(std::is_enum_v<T1>) {
						auto v1 = static_cast<typename std::underlying_type<T1>::type>(convert(v0));
						return static_cast<T1>(v1);
					}
					else if constexpr(is_vector_type<T1>) {
						T1 v1;
						parse_value_list<T1, typename T1::value_type, T1::length()>(v0, v1);
						return v1;
					}
					else if constexpr(std::is_same_v<T1, Mat4> || std::is_same_v<T1, Mat3x4>) {
						T1 v1;
						parse_value_list<T1, typename T1::value_type, T1::length() * 4>(v0, v1);
						return v1;
					}
					else if constexpr(std::is_same_v<T1, Srgba> || std::is_same_v<T1, HdrColor>) {
						T1 v1;
						parse_value_list<T1, typename T1::value_type, v1.size()>(v0, v1);
						return v1;
					}
					else if constexpr(std::is_same_v<T1, EulerAngles>) {
						T1 v1;
						parse_value_list<T1, float, 3>(v0, v1);
						return v1;
					}
					else if constexpr(std::is_same_v<T1, Quaternion>) {
						T1 v1;
						parse_value_list<T1, typename T1::value_type, T1::length(), translate_quaternion_index>(v0, v1);
						return v1;
					}
					else if constexpr(std::derived_from<T1, Transform>) {
						T1 v1;
						using TTranslation = decltype(T1::translation);
						parse_value_list<TTranslation, typename TTranslation::value_type, TTranslation::length()>(v0, v1.translation);
						using TRotation = decltype(T1::rotation);
						parse_value_list<TRotation, typename TRotation::value_type, TRotation::length(), translate_quaternion_index>(v0, v1.rotation);
						if constexpr(std::is_same_v<T1, ScaledTransform>) {
							using TScale = decltype(T1::scale);
							parse_value_list<TScale, typename TScale::value_type, TScale::length()>(v0, v1.scale);
						}
						return v1;
					}
					else if constexpr(std::is_same_v<T1, Utf8String>) {
						std::vector<uint8_t> data;
						data.resize(v0.size() + 1);
						std::memcpy(data.data(), v0.data(), v0.size());
						data.back() = '\0';
						return T1 {std::move(data)};
					}
					else
						return static_cast<T1>(v0);
				}
			};

			template<typename T0, typename T1>
			    requires(std::derived_from<T0, Transform> && (std::is_same_v<T1, Mat4> || std::is_same_v<T1, Mat3x4>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0) { return v0.ToMatrix(); }
			};

			template<typename T0, typename T1>
			    requires(std::is_same_v<T0, Srgba> && std::is_same_v<T1, HdrColor>)
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0) { return T1 {v0[0], v0[1], v0[2]}; }
			};

			template<typename T0, typename T1>
			    requires(std::derived_from<T0, Quat> && std::is_same_v<T1, Mat3x4>)
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0) { return umat::create(v0); }
			};

			template<typename T0, typename T1>
			    requires(std::derived_from<T0, EulerAngles> && (std::derived_from<T1, Transform> || std::is_same_v<T1, Mat4> || std::is_same_v<T1, Mat3x4>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					if constexpr(std::is_same_v<T1, Mat4> || std::is_same_v<T1, Mat3x4>)
						return umat::create(uquat::create(v0));
					else
						return T1 {uquat::create(v0)};
				}
			};

			template<typename T0, typename T1>
			    requires(std::is_same_v<T0, Vector3> && (std::is_same_v<T1, Srgba> || std::is_same_v<T1, HdrColor>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					return T1 {static_cast<typename T1::value_type>(std::clamp<float>(v0.x * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
					  static_cast<typename T1::value_type>(std::clamp<float>(v0.y * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
					  static_cast<typename T1::value_type>(std::clamp<float>(v0.z * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max()))};
				}
			};

			template<typename T0, typename T1>
			    requires(std::is_same_v<T0, Vector4> && (std::is_same_v<T1, Srgba> || std::is_same_v<T1, HdrColor>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					if constexpr(std::is_same_v<T1, Srgba>) {
						return T1 {static_cast<typename T1::value_type>(std::clamp<float>(v0.x * std::numeric_limits<typename T1::value_type>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
						  static_cast<typename T1::value_type>(std::clamp<float>(v0.y * std::numeric_limits<typename T1::value_type>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
						  static_cast<typename T1::value_type>(std::clamp<float>(v0.z * std::numeric_limits<typename T1::value_type>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
						  static_cast<typename T1::value_type>(std::clamp<float>(v0.w * std::numeric_limits<typename T1::value_type>::max(), 0, std::numeric_limits<typename T1::value_type>::max()))};
					}
					else {
						return T1 {static_cast<typename T1::value_type>(std::clamp<float>(v0.x * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
						  static_cast<typename T1::value_type>(std::clamp<float>(v0.y * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max())),
						  static_cast<typename T1::value_type>(std::clamp<float>(v0.z * std::numeric_limits<uint8_t>::max(), 0, std::numeric_limits<typename T1::value_type>::max()))};
					}
				}
			};

			template<typename T0, typename T1>
			    requires((std::is_same_v<T0, Srgba> || std::is_same_v<T0, HdrColor>) && (std::is_same_v<T1, Vector3> || std::is_same_v<T1, Vector4>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					if constexpr(std::is_same_v<T1, Vector3>) {
						return T1 {v0[0] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[1] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[2] / static_cast<float>(std::numeric_limits<uint8_t>::max())};
					}
					else {
						if constexpr(std::is_same_v<T0, HdrColor>) {
							return T1 {v0[0] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[1] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[2] / static_cast<float>(std::numeric_limits<uint8_t>::max()), 1.f};
						}
						else {
							return T1 {v0[0] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[1] / static_cast<float>(std::numeric_limits<uint8_t>::max()), v0[2] / static_cast<float>(std::numeric_limits<uint8_t>::max()),
							  v0[3] / static_cast<float>(std::numeric_limits<uint8_t>::max())};
						}
					}
				}
			};

			template<typename T0, typename T1>
			    requires(std::is_same_v<T0, T1> && (std::is_same_v<T0, Srgba> || std::is_same_v<T0, HdrColor>))
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0) { return v0; }
			};

			template<typename T0, typename T1>
			    requires((std::is_arithmetic_v<T0> || pragma::math::is_vector_type<T0> || pragma::math::is_matrix_type<T0> || std::is_same_v<T0, Quat> || std::is_same_v<T0, EulerAngles> || std::is_same_v<T0, Srgba> || std::is_same_v<T0, HdrColor> || std::is_same_v<T0, Transform>
			               || std::is_same_v<T0, ScaledTransform> || std::is_same_v<T0, Reference> || std::is_same_v<T0, Half> || std::is_same_v<T0, Nil>)
			      && std::is_same_v<T1, String>)
			struct TypeConverter<T0, T1> {
				static constexpr auto is_convertible = true;
				static T1 convert(const T0 &v0)
				{
					if constexpr(std::is_arithmetic_v<T0>)
						return std::to_string(v0);
					else if constexpr(pragma::math::is_vector_type<T0>)
						return uvec::to_string<T0>(v0, ' ');
					else if constexpr(pragma::math::is_matrix_type<T0>)
						return umat::to_string<T0>(v0, ' ');
					else if constexpr(std::is_same_v<T0, Quat>)
						return uquat::to_string(v0, ' ');
					else if constexpr(std::is_same_v<T0, EulerAngles>)
						return std::to_string(v0.p) + ' ' + std::to_string(v0.y) + ' ' + std::to_string(v0.r);
					else if constexpr(std::is_same_v<T0, Srgba>)
						return std::to_string(v0[0]) + ' ' + std::to_string(v0[1]) + ' ' + std::to_string(v0[2]) + ' ' + std::to_string(v0[3]);
					else if constexpr(std::is_same_v<T0, HdrColor>)
						return std::to_string(v0[0]) + ' ' + std::to_string(v0[1]) + ' ' + std::to_string(v0[2]);
					else if constexpr(std::is_same_v<T0, Transform>)
						return '[' + uvec::to_string<Vector3>(v0.GetOrigin(), ' ') + "][" + uquat::to_string(v0.GetRotation(), ' ') + ']';
					else if constexpr(std::is_same_v<T0, ScaledTransform>)
						return '[' + uvec::to_string<Vector3>(v0.GetOrigin(), ' ') + "][" + uquat::to_string(v0.GetRotation(), ' ') + "][" + uvec::to_string<Vector3>(v0.GetScale(), ' ') + ']';
					else if constexpr(std::is_same_v<T0, Reference>)
						return v0.path;
					else if constexpr(std::is_same_v<T0, Half>)
						return std::to_string(static_cast<float>(v0));
					else if constexpr(std::is_same_v<T0, Nil>)
						return "nil";
				}
			};
		};
		template<typename TFrom, typename TTo>
		constexpr bool is_convertible()
		{
			return detail::TypeConverter<TFrom, TTo>::is_convertible;
		}
		template<typename TFrom, typename TTo>
		    requires(is_convertible<TFrom, TTo>())
		constexpr TTo convert(const TFrom &from)
		{
			return detail::TypeConverter<TFrom, TTo>::convert(from);
		}
		template<typename TTo>
		constexpr bool is_convertible_from(Type tFrom);
		template<typename TFrom>
		constexpr bool is_convertible(Type tTo);
		constexpr bool is_convertible(Type tFrom, Type tTo);
	};
	template<typename TTo>
	constexpr bool udm::is_convertible_from(Type tFrom)
	{
		if(is_ng_type(tFrom))
			return visit_ng(tFrom, [&](auto tag) { return is_convertible<typename decltype(tag)::type, TTo>(); });
		switch(tFrom) {
		case Type::String:
			return is_convertible<String, TTo>();
		case Type::Reference:
			return is_convertible<Reference, TTo>();
		}
		return false;
	}

	template<typename TFrom>
	constexpr bool udm::is_convertible(Type tTo)
	{
		if(is_ng_type(tTo))
			return visit_ng(tTo, [&](auto tag) { return is_convertible<TFrom, typename decltype(tag)::type>(); });
		switch(tTo) {
		case Type::String:
			return is_convertible<TFrom, String>();
		case Type::Reference:
			return is_convertible<TFrom, Reference>();
		}
		return false;
	}

	constexpr bool udm::is_convertible(Type tFrom, Type tTo)
	{
		if(is_ng_type(tFrom))
			return visit_ng(tFrom, [&](auto tag) { return is_convertible<typename decltype(tag)::type>(tTo); });
		switch(tFrom) {
		case Type::String:
			return is_convertible<String>(tTo);
		case Type::Reference:
			return is_convertible<Reference>(tTo);
		}
		return false;
	}
#ifdef _WIN32
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#endif
}

// --- END PARTITION: src/interface/conversion.cppm ---

// --- BEGIN PARTITION: src/interface/struct.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:structure;

export import :basic_types;
export import :enums;
import :exception;
import :trivial_types;
*/

// --- START BODY: src/interface/struct.cppm ---

export {
	namespace udm {
		struct DLLUDM StructDescription {
			using SizeType = uint16_t;
			using MemberCountType = uint8_t;
			std::string GetTemplateArgumentList() const;
			SizeType GetDataSizeRequirement() const;
			MemberCountType GetMemberCount() const;

			// TODO: Use these once C++20 is available
			// bool operator==(const Struct&) const=default;
			// bool operator!=(const Struct&) const=default;
			bool operator==(const StructDescription &other) const;
			bool operator!=(const StructDescription &other) const { return !operator==(other); }

			template<typename T1, typename T2, typename... T>
			static StructDescription Define(std::initializer_list<std::string> names)
			{
				StructDescription strct {};
				strct.DefineTypes<T1, T2, T...>(names);
				return strct;
			}

			template<typename T1, typename T2, typename... T>
			void DefineTypes(std::initializer_list<std::string> names)
			{
				Clear();
				constexpr auto n = sizeof...(T) + 2;
				if(names.size() != n)
					throw InvalidUsageError {"Number of member names has to match number of member types!"};
				types.reserve(n);
				this->names.reserve(n);
				DefineTypes<T1, T2, T...>(names.begin());
			}

			void Clear()
			{
				types.clear();
				names.clear();
			}
			std::vector<Type> types;
			std::vector<String> names;
		  private:
			template<typename T1, typename T2, typename... T>
			void DefineTypes(std::initializer_list<std::string>::iterator it);
			template<typename T>
			void DefineTypes(std::initializer_list<std::string>::iterator it);
		};

		template<typename T1, typename T2, typename... T>
		void StructDescription::DefineTypes(std::initializer_list<std::string>::iterator it)
		{
			DefineTypes<T1>(it);
			DefineTypes<T2, T...>(it + 1);
		}
		template<typename T>
		void StructDescription::DefineTypes(std::initializer_list<std::string>::iterator it)
		{
			types.push_back(type_to_enum<T>());
			names.push_back(*it);
		}

		struct DLLUDM Struct {
			static constexpr auto MAX_SIZE = std::numeric_limits<StructDescription::SizeType>::max();
			static constexpr auto MAX_MEMBER_COUNT = std::numeric_limits<StructDescription::MemberCountType>::max();
			Struct() = default;
			Struct(const Struct &) = default;
			Struct(Struct &&) = default;
			Struct(const StructDescription &desc);
			Struct(StructDescription &&desc);
			Struct &operator=(const Struct &) = default;
			Struct &operator=(Struct &&) = default;
			template<class T>
			Struct &operator=(const T &other);
			void Assign(const void *inData, size_t inSize)
			{
				auto sz = description.GetDataSizeRequirement();
				if(inSize != sz)
					throw LogicError {"Attempted to assign data of size " + std::to_string(inSize) + " to struct of size " + std::to_string(sz) + "!"};
				if(data.size() != sz)
					throw ImplementationError {"Size of struct data does not match its types!"};
				memcpy(data.data(), inData, inSize);
			}
			// TODO: Use these once C++20 is available
			// bool operator==(const Struct&) const=default;
			// bool operator!=(const Struct&) const=default;
			bool operator==(const Struct &other) const;
			bool operator!=(const Struct &other) const { return !operator==(other); }

			StructDescription &operator*() { return description; }
			const StructDescription &operator*() const { return const_cast<Struct *>(this)->operator*(); }
			StructDescription *operator->() { return &description; }
			const StructDescription *operator->() const { return const_cast<Struct *>(this)->operator->(); }

			void Clear();
			void UpdateData();
			void SetDescription(const StructDescription &desc);
			void SetDescription(StructDescription &&desc);
			StructDescription description;
			std::vector<uint8_t> data;
		};
		template<class T>
		Struct &Struct::operator=(const T &other)
		{
			Assign(&other, sizeof(T));
			return *this;
		}
	}
}

// --- END PARTITION: src/interface/struct.cppm ---

// --- BEGIN PARTITION: src/interface/wrapper_funcs.cppm ---
/*
// SPDX-FileCopyrightText: © 2025 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:wrapper_funcs;

export import :basic_types;
export import :enums;
export import :trivial_types;
export import pragma.util;
*/

// --- START BODY: src/interface/wrapper_funcs.cppm ---

export namespace udm {
	// Utility functions to prevent circular dependencies
	// It would be better to simply put the definitions for these functions into
	// a separate partition, but that currently causes unresolved external symbol errors with
	// msvc.
	// TODO: Once the msvc compiler issues are fixed, these functions can be removed and replaced with the
	// underlying function calls.
	template<typename T>
	PProperty create_property(T &&value);
	template<const char *>
	PProperty create_property(const char *v)
	{
		return create_property(std::string_view(v));
	}
	template<std::size_t N>
	PProperty create_property(const char (&v)[N])
	{
		return create_property(std::string_view(v));
	}
	PProperty copy_property(const Property &prop);
	Type get_property_type(const Property &prop);
	Type get_property_type(const PropertyWrapper &prop);
	bool is_property_type(const Property &prop, Type type);
	DataValue get_property_value(Property &prop);
	DataValue get_property_value(PropertyWrapper &prop);
	template<typename T>
	T &get_property_value(Property &prop);
	template<typename T>
	T &get_property_value(PropertyWrapper &prop);
	template<typename T>
	T *get_property_value_ptr(Property &prop);
	template<typename T>
	std::optional<T> to_property_value(Property &prop);

	// Any struct or class that isn't a UDM type is assumed to be a struct type
	template<typename T>
	concept is_struct_type = std::is_class_v<T> && type_to_enum_s<T>() == Type::Invalid && !pragma::util::is_specialization<T, std::vector>::value && !pragma::util::is_specialization<T, std::shared_ptr>::value && !pragma::util::is_specialization_array<T>::value;

	template<typename T>
	    requires(!is_struct_type<T>)
	void set_property_value(Property &prop, T &&value);
	template<typename T>
	    requires(is_struct_type<T>)
	void set_property_value(Property &prop, T &value)
	{
		// Not supported(?)
	}
	template<const char *>
	void set_property_value(Property &prop, const char *v)
	{
		set_property_value(prop, std::string_view(v));
	}
	template<std::size_t N>
	void set_property_value(Property &prop, const char (&v)[N])
	{
		set_property_value(prop, std::string_view(v));
	}

	template<class T>
	BlobResult get_property_blob_data(Property &prop, T &v);

	Type get_array_value_type(const Array &a);
	template<typename T>
	T &get_array_value(Array &a, uint32_t idx);
	template<typename T>
	T *get_array_value_ptr(Array &a, uint32_t idx);

	uint16_t get_array_structured_data_info_data_size_requirement(Array &a);
	// Since we can't know all struct types ahead of time, we handle them separately
	template<typename T>
	    requires(!is_struct_type<T>)
	void set_array_value(Array &a, uint32_t idx, T &&v);
	template<const char *>
	void set_array_value(Array &a, uint32_t idx, const char *v)
	{
		set_array_value(a, idx, std::string_view(v));
	}
	template<std::size_t N>
	void set_array_value(Array &a, uint32_t idx, const char (&v)[N])
	{
		set_array_value(a, idx, std::string_view(v));
	}

	uint32_t get_array_value_size(const Array &a);
	uint32_t get_array_size(const Array &a);
	void *get_array_values(Array &a);
	bool is_array_value_type(const Array &a, Type pvalueType);

	template<typename T>
	class ArrayIterator;
	template<typename T>
	void get_array_begin_iterator(Array &a, ArrayIterator<T> &outIt);
	template<typename T>
	void get_array_end_iterator(Array &a, ArrayIterator<T> &outIt);

	PProperty *find_element_child(Element &e, const std::string_view &key);
	void remove_element_child(Element &e, const std::string_view &key);
	void erase_element_child(Element &e, Element &child);
	void set_element_child_value(Element &e, const std::string_view &key, const PProperty &prop);

	template<typename T>
	void set_element_value(Element &parent, Element &child, T &&v);
	template<const char *>
	void set_element_value(Element &parent, Element &child, const char *v)
	{
		set_element_value(parent, child, std::string_view(v));
	}
	template<std::size_t N>
	void set_element_value(Element &parent, Element &child, const char (&v)[N])
	{
		set_element_value(parent, child, std::string_view(v));
	}

	PropertyWrapper &get_element_parent_property(Element &e);

	void set_struct_value(Struct &strct, const void *inData, size_t inSize);

	template<typename T>
	    requires(is_struct_type<T>)
	void set_array_value(Array &a, uint32_t idx, T &v)
	{
		using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
		auto valueType = get_array_value_type(a);
		if(valueType == Type::Struct) {
			if constexpr(!std::is_fundamental_v<std::remove_extent_t<TBase>>) {
				auto sz = get_array_structured_data_info_data_size_requirement(a);
				if(sizeof(T) != sz)
					throw LogicError {"Attempted to assign data of size " + std::to_string(sizeof(T)) + " to struct of size " + std::to_string(sz) + "!"};
				if constexpr(std::is_rvalue_reference_v<T>)
					static_cast<TBase *>(get_array_values(a))[idx] = std::move(v);
				else
					static_cast<TBase *>(get_array_values(a))[idx] = v;
			}
			else
				throw LogicError {"Attempted to assign fundamental type '" + std::string {typeid(T).name()} + "' to struct, this is not allowed!"};
			return;
		}
	}
}

// --- END PARTITION: src/interface/wrapper_funcs.cppm ---

// --- BEGIN PARTITION: src/interface/property_wrapper.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:property_wrapper;

import :conversion;
export import :enums;
export import :trivial_types;
export import :types;
import :wrapper_funcs;
import pragma.util;
*/

// --- START BODY: src/interface/property_wrapper.cppm ---

export {
	namespace udm {
		template<typename T>
		class ArrayIterator;
		struct DLLUDM PropertyWrapper {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			PropertyWrapper() = default;
			explicit PropertyWrapper(Property &o);
			PropertyWrapper(const PropertyWrapper &other);
			PropertyWrapper(Array &array, uint32_t idx);
			template<typename T>
			void operator=(T &&v) const;
			void operator=(const PropertyWrapper &other);
			void operator=(PropertyWrapper &other);
			void operator=(PropertyWrapper &&other);
			void operator=(const LinkedPropertyWrapper &other);
			void operator=(LinkedPropertyWrapper &other);
			void operator=(Property &other);
			//template<typename T>
			//	operator T() const;
			LinkedPropertyWrapper Add(const std::string_view &path, Type type = Type::Element, bool pathToElements = false) const;
			LinkedPropertyWrapper AddArray(const std::string_view &path, std::optional<uint32_t> size = {}, Type type = Type::Element, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			LinkedPropertyWrapper AddArray(const std::string_view &path, StructDescription &&strct, std::optional<uint32_t> size = {}, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			LinkedPropertyWrapper AddArray(const std::string_view &path, const StructDescription &strct, std::optional<uint32_t> size = {}, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			template<typename T>
			LinkedPropertyWrapper AddArray(const std::string_view &path, const StructDescription &strct, const T *data, uint32_t strctItems, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			template<typename T>
			LinkedPropertyWrapper AddArray(const std::string_view &path, const StructDescription &strct, const std::vector<T> &values, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			template<typename T>
			LinkedPropertyWrapper AddArray(const std::string_view &path, const std::vector<T> &values, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			template<typename T>
			LinkedPropertyWrapper AddArray(const std::string_view &path, uint32_t size, const T *data, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false) const;
			bool IsArrayItem() const;
			bool IsType(Type type) const;
			Type GetType() const;
			Hash CalcHash() const;
			void Merge(const PropertyWrapper &other, MergeFlags mergeFlags = MergeFlags::OverwriteExisting) const;

			Array *GetOwningArray() const;
			BlobResult GetBlobData(void *outBuffer, size_t bufferSize, uint64_t *optOutRequiredSize = nullptr) const;
			BlobResult GetBlobData(void *outBuffer, size_t bufferSize, Type type, uint64_t *optOutRequiredSize = nullptr) const;
			Blob GetBlobData(Type &outType) const;
			template<class T>
			BlobResult GetBlobData(T &v) const;
			template<typename T>
			T &GetValue() const;
			template<typename T>
			T *GetValuePtr() const;
			void *GetValuePtr(Type &outType) const;
			template<typename T>
			T ToValue(const T &defaultValue, bool *optOutIsDefined = nullptr) const;
			template<typename T>
			std::optional<T> ToValue() const;
			template<typename T>
			bool operator>>(T &valOut) const
			{
				return (*this)(valOut);
			}
			template<typename T>
			T operator()(const T &defaultValue) const
			{
				return ToValue<T>(defaultValue);
			}
			template<typename T>
			T operator()(const T &defaultValue, bool &outIsDefined) const
			{
				return ToValue<T>(defaultValue, &outIsDefined);
			}
			template<typename T>
			bool operator()(T &valOut) const
			{
				using TBase = std::remove_reference_t<T>;
				if constexpr(pragma::util::is_specialization<TBase, std::optional>::value) {
					typename TBase::value_type v;
					if(!(*this)(v)) {
						valOut = {};
						return false;
					}
					valOut = v;
					return true;
				}
				else if constexpr(pragma::util::is_specialization<TBase, std::vector>::value || pragma::util::is_specialization<TBase, std::map>::value || pragma::util::is_specialization<TBase, std::unordered_map>::value) {
					bool isDefined;
					valOut = std::move((*this)(const_cast<const T &>(valOut), isDefined));
					return isDefined;
				}
				else if constexpr(std::is_enum_v<TBase>) {
					using TEnum = TBase;
					auto *ptr = GetValuePtr<std::string>();
					if(ptr) {
						auto e = magic_enum::enum_cast<TEnum>(*ptr);
						if(!e.has_value())
							return false;
						valOut = *e;
						return true;
					}
					bool isDefined;
					valOut = static_cast<TEnum>((*this)(reinterpret_cast<const std::underlying_type_t<TEnum> &>(valOut), isDefined));
					return isDefined;
				}
				else if constexpr(std::is_same_v<TBase, PProperty>) {
					if(!prop)
						return false;
					valOut->Assign<false>(*prop);
					return true;
				}
				else if constexpr(std::is_same_v<TBase, Property>) {
					if(!prop)
						return false;
					valOut.Assign<false>(*prop);
					return true;
				}
				else {
					auto *ptr = GetValuePtr<T>();
					if(ptr) {
						valOut = *ptr;
						return true;
					}
					bool isDefined;
					valOut = (*this)(const_cast<const T &>(valOut), isDefined);
					return isDefined;
				}
			}

			// For array properties
			uint32_t GetSize() const;
			void Resize(uint32_t size) const;
			template<typename T>
			ArrayIterator<T> begin() const;
			template<typename T>
			ArrayIterator<T> end() const;
			ArrayIterator<LinkedPropertyWrapper> begin() const;
			ArrayIterator<LinkedPropertyWrapper> end() const;
			LinkedPropertyWrapper operator[](uint32_t idx) const;
			LinkedPropertyWrapper operator[](int32_t idx) const;
			LinkedPropertyWrapper operator[](size_t idx) const;
			//

			// For element properties
			ElementIterator begin_el() const;
			ElementIterator end_el() const;
			uint32_t GetChildCount() const;
			//

			LinkedPropertyWrapper GetFromPath(const std::string_view &key) const;
			LinkedPropertyWrapper operator[](const std::string_view &key) const;
			LinkedPropertyWrapper operator[](const std::string &key) const;
			LinkedPropertyWrapper operator[](const char *key) const;
			bool operator==(const PropertyWrapper &other) const;
			bool operator!=(const PropertyWrapper &other) const;
			template<typename T>
			bool operator==(const T &other) const;
			template<typename T>
			bool operator!=(const T &other) const
			{
				return !operator==(other);
			}
			Property &operator*() const;
			Property *operator->() const;
			operator bool() const;
			Property *prop = nullptr;
			uint32_t arrayIndex = std::numeric_limits<uint32_t>::max();

			LinkedPropertyWrapper *GetLinked();
			const LinkedPropertyWrapper *GetLinked() const { return const_cast<PropertyWrapper *>(this)->GetLinked(); };
		  protected:
			bool IsArrayItem(bool includeIfElementOfArrayItem) const;
			bool linked = false;
		};

		struct DLLUDM LinkedPropertyWrapper : public PropertyWrapper {
			static constexpr std::uint32_t layout_version = 1; // Increment this whenever members of this class are changed

			LinkedPropertyWrapper() : PropertyWrapper {} { linked = true; }
			LinkedPropertyWrapper(const LinkedPropertyWrapper &other);
			LinkedPropertyWrapper(const PropertyWrapper &other) : PropertyWrapper {other} { linked = true; }
			LinkedPropertyWrapper(Property &o) : PropertyWrapper {o} { linked = true; }
			LinkedPropertyWrapper(Array &array, uint32_t idx) : PropertyWrapper {array, idx} { linked = true; }
			bool operator==(const LinkedPropertyWrapper &other) const;
			bool operator!=(const LinkedPropertyWrapper &other) const;
			using PropertyWrapper::operator==;
			using PropertyWrapper::operator!=;
			template<typename T>
			void operator=(T &&v) const;
			void operator=(PropertyWrapper &&v);
			void operator=(LinkedPropertyWrapper &&v);
			void operator=(const PropertyWrapper &v);
			void operator=(const LinkedPropertyWrapper &v);

			// Alias
			template<typename T>
			void operator<<(T &&v)
			{
				operator=(v);
			}

			LinkedPropertyWrapper operator[](uint32_t idx) const;
			LinkedPropertyWrapper operator[](int32_t idx) const;
			LinkedPropertyWrapper operator[](size_t idx) const;

			LinkedPropertyWrapper operator[](const std::string_view &key) const;
			LinkedPropertyWrapper operator[](const std::string &key) const;
			LinkedPropertyWrapper operator[](const char *key) const;

			std::string GetPath() const;
			PProperty ClaimOwnership() const;
			ElementIteratorWrapper ElIt();
			std::unique_ptr<LinkedPropertyWrapper> prev = nullptr;
			std::string propName;

			// For internal use only!
			void InitializeProperty(Type type = Type::Element, bool getOnly = false);
			Property *GetProperty(std::vector<uint32_t> *optOutArrayIndices = nullptr) const;
		};

		template<typename TEnum>
		TEnum string_to_enum(LinkedPropertyWrapperArg udmEnum, TEnum def)
		{
			std::string str;
			udmEnum(str);
			auto e = magic_enum::enum_cast<TEnum>(str);
			return e.has_value() ? *e : def;
		}

		template<typename TEnum>
		TEnum string_to_flags(LinkedPropertyWrapperArg udmEnum, TEnum def)
		{
			std::string str;
			udmEnum(str);
			auto e = magic_enum::enum_flags_cast<TEnum>(str);
			return e.has_value() ? *e : def;
		}

		template<typename TEnum>
		void to_enum_value(LinkedPropertyWrapperArg udmEnum, TEnum &def)
		{
			std::string str;
			udmEnum(str);
			auto e = magic_enum::enum_cast<TEnum>(str);
			def = e.has_value() ? *e : def;
		}

		template<typename TEnum>
		void to_flags(LinkedPropertyWrapperArg udmEnum, TEnum &def)
		{
			std::string str;
			udmEnum(str);
			auto e = magic_enum::enum_flags_cast<TEnum>(str);
			def = e.has_value() ? *e : def;
		}

		template<typename TEnum>
		void write_flag(LinkedPropertyWrapperArg udm, TEnum flags, TEnum flag, const std::string_view &name)
		{
			if(pragma::math::is_flag_set(flags, flag) == false)
				return;
			udm[name] = true;
		}
		template<typename TEnum>
		void read_flag(LinkedPropertyWrapperArg udm, TEnum &flags, TEnum flag, const std::string_view &name)
		{
			if(!udm)
				return;
			pragma::math::set_flag(flags, flag, udm[name](false));
		}
	}

	namespace udm {
		template<typename T>
		void LinkedPropertyWrapper::operator=(T &&v) const
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			if(prop == nullptr) {
				if constexpr(pragma::util::is_specialization<TBase, std::optional>::value) {
					if(!v) // nullopt
						return;
				}
				const_cast<LinkedPropertyWrapper *>(this)->InitializeProperty();
			}
			/*if(prev && prev->arrayIndex != std::numeric_limits<uint32_t>::max() && prev->prev && prev->prev->prop && prev->prev->prop->type == Type::Array)
			{
				(*static_cast<Array*>(prev->prev->prop->value))[prev->arrayIndex][propName] = v;
				return;
			}*/
			PropertyWrapper::operator=(v);
		}

		template<typename T>
		void PropertyWrapper::operator=(T &&v) const
		{
			if(prop == nullptr)
				throw LogicError {"Cannot assign property value: Property is invalid!"};
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			if constexpr(pragma::util::is_specialization<TBase, std::optional>::value) {
				// Value is std::optional
				if(!v) {
					// nullopt case
					// TODO: This code is somewhat redundant (see other cases below) and should be streamlined
					if(is_array_type(get_property_type(*prop))) {
						if(arrayIndex == std::numeric_limits<uint32_t>::max())
							throw LogicError {"Cannot assign propety value to array: No index has been specified!"};
						if(linked && !static_cast<const LinkedPropertyWrapper *>(this)->propName.empty()) {
							auto &a = *static_cast<Array *>(get_property_value(*prop));
							if(get_array_value_type(a) != Type::Element)
								return;
							auto &e = get_array_value<Element>(a, arrayIndex);
							remove_element_child(e, static_cast<const LinkedPropertyWrapper *>(this)->propName);
						}
						else
							throw LogicError {"Cannot assign nullopt value to array!"};
						return;
					}
					if constexpr(std::is_same_v<TBase, PProperty>) {
						if(linked && !static_cast<const LinkedPropertyWrapper *>(this)->propName.empty()) {
							auto &linked = *GetLinked();
							if(linked.prev && linked.prev->IsType(Type::Element)) {
								auto &el = linked.prev->GetValue<Element>();
								remove_element_child(el, linked.propName);
								return;
							}
						}
					}
					if(get_property_type(*prop) != Type::Element) {
						throw LogicError {"Cannot assign nullopt value to concrete UDM value!"};
						return;
					}
					if constexpr(type_to_enum_s<TBase>() != Type::Invalid) {
						if(get_property_value(*prop) == nullptr)
							throw LogicError {"Cannot assign property value: Property is invalid!"};
						auto &el = *static_cast<Element *>(get_property_value(*prop));
						auto &wpParent = get_element_parent_property(el);
						if(!wpParent)
							throw InvalidUsageError {"Attempted to change value of element property without a valid parent, this is not allowed!"};
						auto &parent = wpParent;
						switch(get_property_type(parent)) {
						case Type::Element:
							erase_element_child(*static_cast<Element *>(get_property_value(parent)), el);
							break;
						/*case Type::Array:
						if(arrayIndex == std::numeric_limits<uint32_t>::max())
							throw std::runtime_error{"Element has parent of type " +std::string{magic_enum::enum_name(parent->type)} +", but is not indexed!"};
						(*static_cast<Array*>(parent->value))[arrayIndex] = v;
						break;*/
						default:
							throw InvalidUsageError {
							  "Element has parent of type " + std::string {magic_enum::enum_name(get_property_type(parent))} + ", but only " + std::string {magic_enum::enum_name(Type::Element)} /* +" and " +std::string{magic_enum::enum_name(Type::Array)}*/ + " types are allowed!"};
						}
					}
					else
						throw LogicError {"Cannot assign custom type to non-struct property!"};
					return;
				}
				return operator=(*v);
			}
			else if constexpr(std::is_enum_v<std::remove_reference_t<TBase>>)
				return operator=(magic_enum::enum_name(v));
			else {
				if(is_array_type(get_property_type(*prop))) {
					if(arrayIndex == std::numeric_limits<uint32_t>::max())
						throw LogicError {"Cannot assign propety value to array: No index has been specified!"};
					if(linked && !static_cast<const LinkedPropertyWrapper *>(this)->propName.empty()) {
						auto &a = *static_cast<Array *>(get_property_value(*prop));
						if(get_array_value_type(a) != Type::Element)
							return;
						auto &e = get_array_value<Element>(a, arrayIndex);
						if constexpr(type_to_enum_s<TBase>() != Type::Invalid)
							set_element_child_value(e, static_cast<const LinkedPropertyWrapper *>(this)->propName, udm::create_property(v));
						else if constexpr(std::is_same_v<TBase, PProperty>)
							set_element_child_value(e, static_cast<const LinkedPropertyWrapper *>(this)->propName, v);
						else if constexpr(std::is_same_v<TBase, Property>)
							set_element_child_value(e, static_cast<const LinkedPropertyWrapper *>(this)->propName, udm::copy_property(v));
						else {
							auto *child = find_element_child(e, static_cast<const LinkedPropertyWrapper *>(this)->propName);
							if(!child || is_property_type(**child, Type::Struct) == false)
								throw LogicError {"Cannot assign custom type to non-struct property!"};
							auto &strct = get_property_value<Struct>(**child);
							set_struct_value(strct, &v, sizeof(T));
						}
					}
					else
						set_array_value(*static_cast<Array *>(get_property_value(*prop)), arrayIndex, v);
					return;
				}
				if constexpr(std::is_same_v<TBase, PProperty>) {
					if(linked && !static_cast<const LinkedPropertyWrapper *>(this)->propName.empty()) {
						auto &linked = *GetLinked();
						if(linked.prev && linked.prev->IsType(Type::Element)) {
							auto &el = linked.prev->GetValue<Element>();
							set_element_child_value(el, linked.propName, v);
							return;
						}
					}
				}
				if(get_property_type(*prop) != Type::Element) {
					set_property_value(*prop, v);
					return;
				}
				if constexpr(type_to_enum_s<TBase>() != Type::Invalid) {
					if(get_property_value(*prop) == nullptr)
						throw LogicError {"Cannot assign property value: Property is invalid!"};
					auto &el = *static_cast<Element *>(get_property_value(*prop));
					auto &wpParent = get_element_parent_property(el);
					if(!wpParent)
						throw InvalidUsageError {"Attempted to change value of element property without a valid parent, this is not allowed!"};
					auto &parent = wpParent;
					switch(get_property_type(parent)) {
					case Type::Element:
						{
							auto *valParent = static_cast<Element *>(get_property_value(parent));
							set_element_value(*valParent, el, v);
							break;
						}
					/*case Type::Array:
						if(arrayIndex == std::numeric_limits<uint32_t>::max())
							throw std::runtime_error{"Element has parent of type " +std::string{magic_enum::enum_name(parent->type)} +", but is not indexed!"};
						(*static_cast<Array*>(parent->value))[arrayIndex] = v;
						break;*/
					default:
						throw InvalidUsageError {
						  "Element has parent of type " + std::string {magic_enum::enum_name(get_property_type(parent))} + ", but only " + std::string {magic_enum::enum_name(Type::Element)} /* +" and " +std::string{magic_enum::enum_name(Type::Array)}*/ + " types are allowed!"};
					}
				}
				else
					throw LogicError {"Cannot assign custom type to non-struct property!"};
			}
		}

		template<typename T>
		LinkedPropertyWrapper PropertyWrapper::AddArray(const std::string_view &path, const StructDescription &strct, const T *data, uint32_t strctItems, ArrayType arrayType, bool pathToElements) const
		{
			auto prop = AddArray(path, strct, strctItems, arrayType, pathToElements);
			auto &a = prop.template GetValue<Array>();
			auto sz = get_array_value_size(a) * get_array_size(a);
			auto *ptr = get_array_values(a);
			memcpy(ptr, data, sz);
			return prop;
		}

		template<typename T>
		LinkedPropertyWrapper PropertyWrapper::AddArray(const std::string_view &path, const StructDescription &strct, const std::vector<T> &values, ArrayType arrayType, bool pathToElements) const
		{
			auto prop = AddArray(path, strct, values.size(), arrayType, pathToElements);
			auto &a = prop.template GetValue<Array>();
			auto sz = a.GetValueSize() * a.GetSize();
			auto szValues = pragma::util::size_of_container(values);
			if(szValues != sz)
				throw InvalidUsageError {"Size of values does not match expected size of defined struct!"};
			auto *ptr = a.GetValues();
			memcpy(ptr, values.data(), szValues);
			return prop;
		}

		template<typename T>
		LinkedPropertyWrapper PropertyWrapper::AddArray(const std::string_view &path, const std::vector<T> &values, ArrayType arrayType, bool pathToElements) const
		{
			return AddArray<T>(path, values.size(), values.data(), arrayType, pathToElements);
		}

		template<typename T>
		LinkedPropertyWrapper PropertyWrapper::AddArray(const std::string_view &path, uint32_t size, const T *data, ArrayType arrayType, bool pathToElements) const
		{
			constexpr auto valueType = type_to_enum<T>();
			auto prop = AddArray(path, size, valueType, arrayType, pathToElements);
			auto &a = prop.template GetValue<Array>();
			if constexpr(is_non_trivial_type(valueType) && valueType != Type::Struct) {
				for(auto i = decltype(size) {0u}; i < size; ++i)
					a[i] = data[i];
			}
			else
				memcpy(a.GetValues(), data, sizeof(T) * size);
			return prop;
		}

		template<class T>
		BlobResult PropertyWrapper::GetBlobData(T &v) const
		{
			uint64_t reqBufferSize = 0;
			auto result = GetBlobData(v.data(), v.size() * sizeof(v[0]), &reqBufferSize);
			if(result == BlobResult::InsufficientSize) {
				if(v.size() * sizeof(v[0]) != reqBufferSize) {
					if((reqBufferSize % sizeof(v[0])) > 0)
						return BlobResult::ValueTypeMismatch;
					v.resize(reqBufferSize / sizeof(v[0]));
					return GetBlobData<T>(v);
				}
				return result;
			}
			if(result != BlobResult::NotABlobType)
				return result;
			if(IsArrayItem(true)) {
				if(linked && !static_cast<const LinkedPropertyWrapper &>(*this).propName.empty()) {
					auto &a = get_property_value<Array>(*prop);
					auto *el = get_array_value_ptr<Element>(a, arrayIndex);
					if(!el)
						return BlobResult::InvalidProperty;
					auto *child = find_element_child(*el, static_cast<const LinkedPropertyWrapper &>(*this).propName);
					if(child)
						return get_property_blob_data<T>(**child, v);
					return BlobResult::InvalidProperty;
				}
				return BlobResult::NotABlobType;
			}
			return get_property_blob_data<T>(**this, v);
		}
		template<typename T>
		T &PropertyWrapper::GetValue() const
		{
			if(arrayIndex != std::numeric_limits<uint32_t>::max()) {
				auto *a = get_property_value_ptr<Array>(*prop);
				if(a) {
					if(linked && !static_cast<const LinkedPropertyWrapper &>(*this).propName.empty()) {
						auto &el = const_cast<Element &>(get_array_value<Element>(*a, arrayIndex));
						auto &propName = static_cast<const LinkedPropertyWrapper &>(*this).propName;
						auto *child = find_element_child(el, propName);
						if(!child)
							throw LogicError {"Attempted to retrieve value of property '" + propName + "' from array element at index " + std::to_string(arrayIndex) + ", but property does not exist!"};
						return get_property_value<T>(**child);
					}
					if(is_array_value_type(*a, type_to_enum<T>()) == false)
						throw LogicError {"Type mismatch, requested type is " + std::string {magic_enum::enum_name(type_to_enum<T>())} + ", but actual type is " + std::string {magic_enum::enum_name(get_array_value_type(*a))} + "!"};
					return static_cast<T *>(get_array_values(*a))[arrayIndex];
				}
			}
			return get_property_value<T>(**this);
		}

		template<typename T>
		T *PropertyWrapper::GetValuePtr() const
		{
			if(arrayIndex != std::numeric_limits<uint32_t>::max()) {
				auto *a = get_property_value_ptr<Array>(*prop);
				if(a) {
					if(linked && !static_cast<const LinkedPropertyWrapper &>(*this).propName.empty()) {
						auto &el = get_array_value<Element>(*a, arrayIndex);
						auto *child = find_element_child(el, static_cast<const LinkedPropertyWrapper &>(*this).propName);
						if(!child)
							return nullptr;
						return get_property_value_ptr<T>(**child);
					}
					if(is_array_value_type(*a, type_to_enum<T>()) == false)
						return nullptr;
					return &static_cast<T *>(get_array_values(*a))[arrayIndex];
				}
			}
			return prop ? get_property_value_ptr<T>(**this) : nullptr;
		}

		template<typename T>
		T PropertyWrapper::ToValue(const T &defaultValue, bool *optOutIsDefined) const
		{
			if(!this) // This can happen in chained expressions. TODO: This is technically undefined behavior and should be implemented differently!
			{
				if(optOutIsDefined)
					*optOutIsDefined = false;
				return defaultValue;
			}
			auto val = ToValue<T>();
			if(val.has_value()) {
				if(optOutIsDefined)
					*optOutIsDefined = true;
				return std::move(val.value());
			}
			if(optOutIsDefined)
				*optOutIsDefined = false;
			return defaultValue;
		}

		template<typename T>
		bool PropertyWrapper::operator==(const T &other) const
		{
			if constexpr(pragma::util::is_c_string<T>())
				return operator==(std::string {other});
			else {
				auto *val = GetValuePtr<T>();
				if(val)
					return *val == other;
				auto valConv = ToValue<T>();
				return valConv.has_value() ? *valConv == other : false;
			}
			return false;
		}

		template<typename T>
		ArrayIterator<T> PropertyWrapper::begin() const
		{
			if(!static_cast<bool>(*this))
				return ArrayIterator<T> {};
			auto *a = GetValuePtr<Array>();
			if(a == nullptr)
				return ArrayIterator<T> {};
			ArrayIterator<T> it;
			get_array_begin_iterator(*a, it);
			if(linked)
				it.GetProperty().prev = std::make_unique<LinkedPropertyWrapper>(*static_cast<LinkedPropertyWrapper *>(const_cast<PropertyWrapper *>(this)));
			return it;
		}
		template<typename T>
		ArrayIterator<T> PropertyWrapper::end() const
		{
			if(!static_cast<bool>(*this))
				return ArrayIterator<T> {};
			auto *a = GetValuePtr<Array>();
			if(a == nullptr)
				return ArrayIterator<T> {};
			ArrayIterator<T> it;
			get_array_end_iterator(*a, it);
			return it;
		}

		template<typename T>
		std::optional<T> PropertyWrapper::ToValue() const
		{
			if(!this) // This can happen in chained expressions. TODO: This is technically undefined behavior and should be implemented differently!
				return {};
			if(IsArrayItem(true)) {
				auto &a = get_property_value<Array>(*prop);
				if(linked && !static_cast<const LinkedPropertyWrapper &>(*this).propName.empty()) {
					auto &el = get_array_value<Element>(a, arrayIndex);
					auto *child = find_element_child(el, static_cast<const LinkedPropertyWrapper &>(*this).propName);
					if(!child)
						return {};
					return to_property_value<T>(**child);
				}
				auto vs = [&](auto tag) -> std::optional<T> {
					if constexpr(is_convertible<typename decltype(tag)::type, T>())
						return std::optional<T> {convert<typename decltype(tag)::type, T>(const_cast<PropertyWrapper *>(this)->GetValue<typename decltype(tag)::type>())};
					return {};
				};
				auto valueType = get_array_value_type(a);
				return visit(valueType, vs);
			}
			if(prop)
				return to_property_value<T>(**this);
			return std::optional<T> {};
		}
	}
}

// --- END PARTITION: src/interface/property_wrapper.cppm ---

// --- BEGIN PARTITION: src/interface/array_iterator.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:array_iterator;

export import :property_wrapper;
export import :types;
import :wrapper_funcs;
*/

// --- START BODY: src/interface/array_iterator.cppm ---

export {
	namespace udm {
		template<typename T>
		class ArrayIterator {
		  public:
			using iterator_category = std::forward_iterator_tag;
			using value_type = T &;
			using difference_type = std::ptrdiff_t;
			using pointer = T *;
			using reference = T &;

			ArrayIterator();
			explicit ArrayIterator(Array &a);
			ArrayIterator(Array &a, uint32_t idx);
			ArrayIterator(const ArrayIterator &other);
			ArrayIterator &operator++();
			ArrayIterator operator++(int);
			ArrayIterator operator+(uint32_t n);
			reference operator*();
			pointer operator->();
			bool operator==(const ArrayIterator &other) const;
			bool operator!=(const ArrayIterator &other) const;

			LinkedPropertyWrapper &GetProperty() { return m_curProperty; }
		  private:
			LinkedPropertyWrapper m_curProperty;
		};

		template<typename T>
		ArrayIterator<T>::ArrayIterator() : m_curProperty {}
		{
		}

		template<typename T>
		ArrayIterator<T>::ArrayIterator(Array &a, uint32_t idx) : m_curProperty {a, idx}
		{
		}

		template<typename T>
		ArrayIterator<T>::ArrayIterator(Array &a) : ArrayIterator {a, 0u}
		{
		}

		template<typename T>
		ArrayIterator<T>::ArrayIterator(const ArrayIterator &other) : m_curProperty {other.m_curProperty}
		{
		}

		template<typename T>
		ArrayIterator<T> &ArrayIterator<T>::operator++()
		{
			++m_curProperty.arrayIndex;
			return *this;
		}

		template<typename T>
		ArrayIterator<T> ArrayIterator<T>::operator++(int)
		{
			auto it = *this;
			it.operator++();
			return it;
		}

		template<typename T>
		ArrayIterator<T> ArrayIterator<T>::operator+(uint32_t n)
		{
			auto it = *this;
			for(auto i = decltype(n) {0u}; i < n; ++i)
				it.operator++();
			return it;
		}

		template<typename T>
		typename ArrayIterator<T>::reference ArrayIterator<T>::operator*()
		{
			if constexpr(std::is_same_v<T, LinkedPropertyWrapper>)
				return m_curProperty;
			else
				return get_property_value<T>(m_curProperty);
		}

		template<typename T>
		typename ArrayIterator<T>::pointer ArrayIterator<T>::operator->()
		{
			if constexpr(std::is_same_v<T, LinkedPropertyWrapper>)
				return &m_curProperty;
			else
				return get_property_value_ptr<T>(m_curProperty);
		}

		template<typename T>
		bool ArrayIterator<T>::operator==(const ArrayIterator &other) const
		{
			auto res = (m_curProperty == other.m_curProperty);
			// UDM_ASSERT_COMPARISON(res);
			return res;
		}

		template<typename T>
		bool ArrayIterator<T>::operator!=(const ArrayIterator &other) const
		{
			return !operator==(other);
		}
	}
}

// --- END PARTITION: src/interface/array_iterator.cppm ---

// --- BEGIN PARTITION: src/interface/asset_data.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:asset_data;

import :core;
export import :property_wrapper;
*/

// --- START BODY: src/interface/asset_data.cppm ---

export {
	namespace udm {
		struct DLLUDM AssetData : public LinkedPropertyWrapper {
			std::string GetAssetType() const;
			Version GetAssetVersion() const;
			void SetAssetType(const std::string &assetType) const;
			void SetAssetVersion(Version version) const;

			LinkedPropertyWrapper GetData() const;
			LinkedPropertyWrapper operator*() const { return GetData(); }
			LinkedPropertyWrapper operator->() const { return GetData(); }
		};
	}
}

// --- END PARTITION: src/interface/asset_data.cppm ---

// --- BEGIN PARTITION: src/interface/element.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:types.element;

export import :property_wrapper;
import :wrapper_funcs;
*/

// --- START BODY: src/interface/element.cppm ---

export {
	namespace udm {
		struct DLLUDM ElementIteratorPair {
			ElementIteratorPair(pragma::string::StringMap<PProperty>::iterator &it);
			ElementIteratorPair();
			bool operator==(const ElementIteratorPair &other) const;
			bool operator!=(const ElementIteratorPair &other) const;
			std::string_view key;
			LinkedPropertyWrapper property;
		};

		class DLLUDM ElementIterator {
		  public:
			using iterator_category = std::forward_iterator_tag;
			using value_type = ElementIteratorPair &;
			using difference_type = std::ptrdiff_t;
			using pointer = ElementIteratorPair *;
			using reference = ElementIteratorPair &;

			ElementIterator();
			ElementIterator(Element &e);
			ElementIterator(Element &e, pragma::string::StringMap<PProperty> &c, pragma::string::StringMap<PProperty>::iterator it);
			ElementIterator(const ElementIterator &other);
			ElementIterator &operator++();
			ElementIterator operator++(int);
			reference operator*();
			pointer operator->();
			bool operator==(const ElementIterator &other) const;
			bool operator!=(const ElementIterator &other) const;
		  private:
			pragma::string::StringMap<PProperty> *m_propertyMap = nullptr;
			pragma::string::StringMap<PProperty>::iterator m_iterator {};
			ElementIteratorPair m_pair;
		};

		struct DLLUDM ElementIteratorWrapper {
			ElementIteratorWrapper(LinkedPropertyWrapper &prop);
			ElementIterator begin();
			ElementIterator end();
		  private:
			LinkedPropertyWrapper m_prop;
		};

		struct DLLUDM Element {
			void AddChild(std::string &&key, const PProperty &o);
			void AddChild(const std::string &key, const PProperty &o);
			void Copy(const Element &other);
			pragma::string::StringMap<PProperty> children;
			PropertyWrapper fromProperty {};
			PropertyWrapper parentProperty {};

			LinkedPropertyWrapper operator[](const std::string &key) { return fromProperty[key]; }
			LinkedPropertyWrapper operator[](const char *key) { return operator[](std::string {key}); }

			LinkedPropertyWrapper Add(const std::string_view &path, Type type = Type::Element, bool pathToElements = false);
			LinkedPropertyWrapper AddArray(const std::string_view &path, std::optional<uint32_t> size = {}, Type type = Type::Element, ArrayType arrayType = ArrayType::Raw, bool pathToElements = false);
			void ToAscii(AsciiSaveFlags flags, std::stringstream &ss, const std::optional<std::string> &prefix = {}) const;

			void Merge(const Element &other, MergeFlags mergeFlags = MergeFlags::OverwriteExisting);

			bool operator==(const Element &other) const;
			bool operator!=(const Element &other) const { return !operator==(other); }
			Element &operator=(Element &&other);
			Element &operator=(const Element &other);

			explicit operator PropertyWrapper &() { return fromProperty; }

			ElementIterator begin();
			ElementIterator end();
		  private:
			friend void erase_element_child(Element &e, Element &child);
			template<typename T>
			friend void set_element_value(Element &parent, Element &child, T &&v);

			template<typename T>
			void SetValue(Element &child, T &&v);
			void EraseValue(const Element &child);
		};

		template<typename T>
		void Element::SetValue(Element &child, T &&v)
		{
			auto it = std::find_if(children.begin(), children.end(), [&child](const std::pair<std::string, PProperty> &pair) { return get_property_type(*pair.second) == Type::Element && get_property_value(*pair.second) == &child; });
			if(it == children.end())
				return;
			children[it->first] = create_property<T>(std::forward<T>(v));
		}
	}
}

// --- END PARTITION: src/interface/element.cppm ---

// --- BEGIN PARTITION: src/interface/array.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"
#include "util_enum_flags.hpp"

export module pragma.udm:array;

export import :array_iterator;
import :types.blob;
export import :conversion;
export import :property_wrapper;
import :structure;
*/

// --- START BODY: src/interface/array.cppm ---

export {
	namespace udm {
		struct DLLUDM Array {
			virtual ~Array();
			PropertyWrapper fromProperty {};

			bool operator==(const Array &other) const;
			bool operator!=(const Array &other) const { return !operator==(other); }

			void Merge(const Array &other, MergeFlags mergeFlags = MergeFlags::OverwriteExisting);

			virtual Array &operator=(Array &&other);
			virtual Array &operator=(const Array &other);

			virtual void SetValueType(Type valueType);
			virtual ArrayType GetArrayType() const { return ArrayType::Raw; }
			bool IsValueType(Type pvalueType) const { return pvalueType == m_valueType; }
			Type GetValueType() const { return m_valueType; }
			uint32_t GetSize() const { return m_size; }
			uint32_t GetValueSize() const;
			virtual void *GetValues() { return GetValuePtr(); }
			const void *GetValues() const { return const_cast<Array *>(this)->GetValues(); }
			void Resize(uint32_t newSize);
			void AddValueRange(uint32_t startIndex, uint32_t count);
			void RemoveValueRange(uint32_t startIndex, uint32_t count);
			void *GetValuePtr(uint32_t idx);
			template<typename T>
			T *GetValuePtr(uint32_t idx);
			template<typename T>
			const T *GetValuePtr(uint32_t idx) const
			{
				return const_cast<Array *>(this)->GetValuePtr<T>(idx);
			}
			PropertyWrapper operator[](uint32_t idx);
			const PropertyWrapper operator[](uint32_t idx) const { return const_cast<Array *>(this)->operator[](idx); }
			template<typename T>
			T &GetValue(uint32_t idx);
			template<typename T>
			const T &GetValue(uint32_t idx) const
			{
				return const_cast<Array *>(this)->GetValue<T>(idx);
			}
			template<typename T>
			void SetValue(uint32_t idx, T &&value);
			template<typename T>
			void InsertValue(uint32_t idx, T &&value);
			void RemoveValue(uint32_t idx);
			// The caller is responsible to ensure that the type of value matches the value type of the array!
			void SetValue(uint32_t idx, const void *value);
			void InsertValue(uint32_t idx, void *value);

			bool IsEmpty() const { return m_size == 0; }
			template<typename T>
			T *GetFront()
			{
				return !IsEmpty() ? GetValuePtr<T>(0u) : nullptr;
			}
			template<typename T>
			const T *GetFront() const
			{
				return const_cast<Array *>(this)->GetFront<T>();
			}
			template<typename T>
			T *GetBack()
			{
				return !IsEmpty() ? GetValuePtr<T>(m_size - 1) : nullptr;
			}
			template<typename T>
			const T *GetBack() const
			{
				return const_cast<Array *>(this)->GetBack<T>();
			}

			template<typename T>
			ArrayIterator<T> begin();
			template<typename T>
			ArrayIterator<T> end();
			ArrayIterator<LinkedPropertyWrapper> begin();
			ArrayIterator<LinkedPropertyWrapper> end();

			uint64_t GetByteSize() const;
			const StructDescription *GetStructuredDataInfo() const { return const_cast<Array *>(this)->GetStructuredDataInfo(); }
			virtual StructDescription *GetStructuredDataInfo();

			static constexpr bool IsValueTypeSupported(Type type) { return true; }

			using Range = std::tuple<uint32_t, uint32_t, uint32_t>;
			void Resize(uint32_t newSize, Range r0, Range r1, bool defaultInitializeNewValues);
		  protected:
			friend Property;
			friend PropertyWrapper;
			virtual void Clear();

			void *GetValuePtr();
			const void *GetValuePtr() const { return const_cast<Array *>(this)->GetValuePtr(); }
			void *GetHeaderPtr();
			const void *GetHeaderPtr() const { return const_cast<Array *>(this)->GetHeaderPtr(); }
			uint64_t GetHeaderSize() const;
			void ReleaseValues();
			uint8_t *AllocateData(uint64_t size) const;

			void *m_values = nullptr;
			uint32_t m_size = 0;
			Type m_valueType = Type::Nil;
		};

		struct DLLUDM ArrayLz4 : public Array {
			enum class Flags : uint8_t {
				None = 0u,
				Compressed = 1u,
				PersistentUncompressedData = Compressed << 1u,
			};

			ArrayLz4() = default;
			virtual ArrayLz4 &operator=(Array &&other) override;
			virtual ArrayLz4 &operator=(const Array &other) override;
			ArrayLz4 &operator=(ArrayLz4 &&other);
			ArrayLz4 &operator=(const ArrayLz4 &other);
			const BlobLz4 &GetCompressedBlob() const { return const_cast<ArrayLz4 *>(this)->GetCompressedBlob(); }
			BlobLz4 &GetCompressedBlob();
			virtual void *GetValues() override;
			virtual void SetValueType(Type valueType) override;
			virtual ArrayType GetArrayType() const override { return ArrayType::Compressed; }
			void ClearUncompressedMemory();
			void SetUncompressedMemoryPersistent(bool persistent);
			using Array::GetStructuredDataInfo;

			static constexpr bool IsValueTypeSupported(Type type);
		  private:
			friend Property;
			friend PropertyWrapper;
			friend AsciiReader;
			virtual StructDescription *GetStructuredDataInfo() override;
			void InitializeSize(uint32_t size);
			void Decompress();
			void Compress();
			virtual void Clear() override;
			std::unique_ptr<StructDescription> m_structuredDataInfo = nullptr;
			Flags m_flags = Flags::None;
			BlobLz4 m_compressedBlob {};
		};

		constexpr bool ArrayLz4::IsValueTypeSupported(Type type) { return is_numeric_type(type) || is_generic_type(type) || type == Type::Struct || type == Type::Element || type == Type::String; }

		template<typename T>
		T *Array::GetValuePtr(uint32_t idx)
		{
			if(type_to_enum<T>() != m_valueType)
				return nullptr;
			return &GetValue<T>(idx);
		}

		template<typename T>
		T &Array::GetValue(uint32_t idx)
		{
			if(idx >= m_size)
				throw OutOfBoundsError {"Array index " + std::to_string(idx) + " out of bounds of array of size " + std::to_string(m_size) + "!"};
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			auto vs = [this, idx](auto tag) -> T & {
				using TTag = typename decltype(tag)::type;
				if constexpr(std::is_same_v<TTag, TBase>)
					return static_cast<TTag *>(GetValues())[idx];
				throw LogicError {"Attempted to retrieve value of type " + std::string {magic_enum::enum_name(type_to_enum<T>())} + " from array of type " + std::string {magic_enum::enum_name(m_valueType)} + "!"};
			};
			auto valueType = GetValueType();
			return visit(valueType, vs);
		}

		template<typename T>
		void Array::InsertValue(uint32_t idx, T &&value)
		{
			auto size = GetSize();
			if(idx > size)
				return;
			Range r0 {0 /* src */, 0 /* dst */, idx};
			Range r1 {idx /* src */, idx + 1 /* dst */, size - idx};
			Resize(size + 1, r0, r1, false);
			if constexpr(std::is_rvalue_reference_v<T>)
				(*this)[idx] = std::move(value);
			else
				(*this)[idx] = value;
		}

		template<typename T>
		void Array::SetValue(uint32_t idx, T &&v)
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			auto valueType = GetValueType();
			if(valueType == Type::Struct) {
				if constexpr(!std::is_fundamental_v<std::remove_extent_t<TBase>>) {
					auto sz = GetStructuredDataInfo()->GetDataSizeRequirement();
					if(sizeof(T) != sz)
						throw LogicError {"Attempted to assign data of size " + std::to_string(sizeof(T)) + " to struct of size " + std::to_string(sz) + "!"};
					if constexpr(std::is_rvalue_reference_v<T>)
						static_cast<TBase *>(GetValues())[idx] = std::move(v);
					else
						static_cast<TBase *>(GetValues())[idx] = v;
				}
				else
					throw LogicError {"Attempted to assign fundamental type '" + std::string {typeid(T).name()} + "' to struct, this is not allowed!"};
				return;
			}
			if(!is_convertible<TBase>(valueType)) {
				throw LogicError {"Attempted to insert value of type " + std::string {magic_enum::enum_name(type_to_enum_s<TBase>())} + " into array of type " + std::string {magic_enum::enum_name(valueType)} + ", which are not compatible!"};
			}

			auto vs = [this, idx, &v](auto tag) {
				using TTag = typename decltype(tag)::type;
				if constexpr(is_convertible<TBase, TTag>())
					static_cast<TTag *>(GetValues())[idx] = convert<TBase, TTag>(v);
			};
			visit(valueType, vs);
		}

		template<typename T>
		ArrayIterator<T> Array::begin()
		{
			return ArrayIterator<T> {*this};
		}
		template<typename T>
		ArrayIterator<T> Array::end()
		{
			return ArrayIterator<T> {*this, GetSize()};
		}
		ArrayIterator<LinkedPropertyWrapper> Array::begin() { return begin<LinkedPropertyWrapper>(); }
		ArrayIterator<LinkedPropertyWrapper> Array::end() { return end<LinkedPropertyWrapper>(); }
	}

	REGISTER_ENUM_FLAGS(udm::ArrayLz4::Flags)
}

// --- END PARTITION: src/interface/array.cppm ---

// --- BEGIN PARTITION: src/interface/util.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:util;

export import :array;
import :structure;
import :types.element;
import :types.string;
*/

// --- START BODY: src/interface/util.cppm ---

export {
	namespace udm {
		std::string CONTROL_CHARACTERS = "{}[]<>$,:;";
		std::string WHITESPACE_CHARACTERS = " \t\f\v\n\r";
		constexpr auto PATH_SEPARATOR = '/';
		DLLUDM bool is_whitespace_character(char c);
		DLLUDM bool is_control_character(char c);
		DLLUDM bool does_key_require_quotes(const std::string_view &key);

		DLLUDM void sanitize_key_name(std::string &key);

		constexpr size_t size_of_base_type(Type t)
		{
			if(is_non_trivial_type(t)) {
				auto tag = get_non_trivial_tag(t);
				return std::visit([&](auto tag) { return sizeof(typename decltype(tag)::type); }, tag);
			}
			return size_of(t);
		}

		template<typename T>
		void lerp_value(const T &value0, const T &value1, float f, T &outValue, Type type)
		{
			using TBase = base_type<T>;
			if constexpr(std::is_same_v<TBase, Transform> || std::is_same_v<TBase, ScaledTransform>) {
				outValue.SetOrigin(uvec::lerp(value0.GetOrigin(), value1.GetOrigin(), f));
				outValue.SetRotation(uquat::slerp(value0.GetRotation(), value1.GetRotation(), f));
				if constexpr(std::is_same_v<TBase, ScaledTransform>)
					outValue.SetScale(uvec::lerp(value0.GetScale(), value1.GetScale(), f));
			}
			else if constexpr(std::is_same_v<TBase, Half>)
				outValue = static_cast<float>(pragma::math::lerp(static_cast<float>(value0), static_cast<float>(value1), f));
			else if constexpr(::udm::is_arithmetic<TBase>)
				outValue = pragma::math::lerp(value0, value1, f);
			else if constexpr(::udm::is_vector_type<TBase>) {
				if constexpr(std::is_integral_v<typename TBase::value_type>)
					; // TODO
				else
					outValue = value0 + (value1 - value0) * f;
			}
			else if constexpr(std::is_same_v<TBase, EulerAngles>) {
				auto q0 = uquat::create(value0);
				auto q1 = uquat::create(value1);
				auto qr = uquat::slerp(q0, q1, f);
				outValue = EulerAngles {qr};
			}
			else if constexpr(std::is_same_v<TBase, Quaternion>)
				outValue = uquat::slerp(value0, value1, f);
			else {
				outValue = value0;
				auto n = udm::get_numeric_component_count(type);
				for(auto i = decltype(n) {0u}; i < n; ++i) {
					auto &f0 = *(reinterpret_cast<const float *>(&value0) + i);
					auto &f1 = *(reinterpret_cast<const float *>(&value1) + i);

					*(reinterpret_cast<float *>(&outValue) + i) = pragma::math::lerp(f0, f1, f);
				}
			}
		}

		void to_json(LinkedPropertyWrapperArg prop, std::stringstream &ss);
	}
}

// --- END PARTITION: src/interface/util.cppm ---

// --- BEGIN PARTITION: src/interface/property.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"
#include <cassert>

export module pragma.udm:property;

import :array;
import :file;
import :types.element;
import :structure;
export import :trivial_types;
export import :types;
import :util;
*/

// --- START BODY: src/interface/property.cppm ---

export {
	namespace udm {
		struct DLLUDM Property {
			template<typename T>
			static void Construct(Property &prop, T &&value);
			template<typename T>
			static void Construct(Property &prop);
			static void Construct(Property &prop, Type type);

			template<typename T>
			static PProperty Create(T &&value);
			template<typename T>
			static PProperty Create();
			static PProperty Create() { return Create<Nil>(); }
			static PProperty Create(Type type);
			Property() = default;
			Property(const Property &other);
			Property(Property &&other);
			~Property();
			bool IsType(Type ptype) const { return ptype == type; }
			Property &operator=(const Property &other);
			Property &operator=(Property &&other) = delete;
			template<typename T>
			void operator=(T &&v);
			void Copy(const Property &other, bool deepCopy);
			PProperty Copy(bool deepCopy = false) const;

			Hash CalcHash() const;

			Type type = Type::Nil;
			DataValue value = nullptr;

			LinkedPropertyWrapper operator[](const std::string &key);
			LinkedPropertyWrapper operator[](const char *key);

			bool operator==(const Property &other) const;
			bool operator!=(const Property &other) const { return !operator==(other); }

			// operator LinkedPropertyWrapper();

			bool Compress();
			bool Decompress(const std::optional<Type> arrayValueType = {});

			BlobResult GetBlobData(void *outBuffer, size_t bufferSize, uint64_t *optOutRequiredSize = nullptr) const;
			BlobResult GetBlobData(void *outBuffer, size_t bufferSize, Type type, uint64_t *optOutRequiredSize = nullptr) const;
			Blob GetBlobData(Type &outType) const;
			template<class T>
			BlobResult GetBlobData(T &v) const;
			template<typename T>
			T &GetValue();
			template<typename T>
			const T &GetValue() const;
			template<typename T>
			T *GetValuePtr();
			void *GetValuePtr(Type &outType);
			template<typename T>
			T ToValue(const T &defaultValue) const;
			template<typename T>
			std::optional<T> ToValue() const;
			operator bool() const { return type != Type::Nil; }

			bool Read(IFile &f);
			bool Read(Type type, IFile &f);
			void Write(IFile &f) const;

			void ToAscii(AsciiSaveFlags flags, std::stringstream &ss, const std::string &propName, const std::string &prefix = "");

			static void ToAscii(AsciiSaveFlags flags, std::stringstream &ss, const std::string &propName, Type type, const DataValue value, const std::string &prefix = "");
			bool Read(IFile &f, Blob &outBlob);
			bool Read(IFile &f, BlobLz4 &outBlob);
			bool Read(IFile &f, Utf8String &outStr);
			bool Read(IFile &f, Element &outEl);
			bool Read(IFile &f, Array &outArray);
			bool Read(IFile &f, ArrayLz4 &outArray);
			static bool Read(IFile &f, String &outStr);
			bool Read(IFile &f, Reference &outRef);
			bool Read(IFile &f, Struct &strct);
			static void Write(IFile &f, const Blob &blob);
			static void Write(IFile &f, const BlobLz4 &blob);
			static void Write(IFile &f, const Utf8String &str);
			static void Write(IFile &f, const Element &el);
			static void Write(IFile &f, const Array &a);
			static void Write(IFile &f, const ArrayLz4 &a);
			static void Write(IFile &f, const String &str);
			static void Write(IFile &f, const Reference &ref);
			static void Write(IFile &f, const Struct &strct);

			static std::string ToAsciiValue(AsciiSaveFlags flags, const Nil &nil, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Blob &blob, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const BlobLz4 &blob, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Utf8String &utf8, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Element &el, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Array &a, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const ArrayLz4 &a, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const String &str, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Reference &ref, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Struct &strct, const std::string &prefix = "");
			static std::string StructToAsciiValue(AsciiSaveFlags flags, const StructDescription &strct, const void *data, const std::string &prefix = "");
			static void ArrayValuesToAscii(AsciiSaveFlags flags, std::stringstream &ss, const Array &a, const std::string &prefix = "");

			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector2 &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector2i &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector3 &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector3i &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector4 &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Vector4i &v, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Quaternion &q, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const EulerAngles &a, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Srgba &srgb, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const HdrColor &col, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Transform &t, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const ScaledTransform &t, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Mat4 &m, const std::string &prefix = "");
			static std::string ToAsciiValue(AsciiSaveFlags flags, const Mat3x4 &m, const std::string &prefix = "");

			static constexpr uint8_t EXTENDED_STRING_IDENTIFIER = std::numeric_limits<uint8_t>::max();
			static BlobResult GetBlobData(const Blob &blob, void *outBuffer, size_t bufferSize);
			static BlobResult GetBlobData(const BlobLz4 &blob, void *outBuffer, size_t bufferSize);
			static Blob GetBlobData(const BlobLz4 &blob);
			static uint32_t GetStringPrefixSizeRequirement(const String &str);
			static uint32_t GetStringSizeRequirement(const String &str);
		  private:
			friend PropertyWrapper;
			bool ReadStructHeader(IFile &f, StructDescription &strct);
			static void WriteStructHeader(IFile &f, const StructDescription &strct);
			template<bool ENABLE_EXCEPTIONS, typename T>
			bool Assign(T &&v);

			template<typename T>
			static uint64_t WriteBlockSize(IFile &f);
			template<typename T>
			static void WriteBlockSize(IFile &f, uint64_t offset);

			template<typename T>
			static void NumericTypeToString(T value, std::stringstream &ss);
			template<typename T>
			static std::string NumericTypeToString(T value);
			static void SetAppropriatePrecision(std::stringstream &ss, Type type);
			static void RemoveTrailingZeroes(std::string &str);
			void Initialize();
			void Clear();
			template<typename T>
			T &GetValue(Type type);
		};

		template<bool ENABLE_EXCEPTIONS, typename T>
		bool Property::Assign(T &&v)
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			if constexpr(pragma::util::is_specialization<TBase, std::vector>::value) {
				using TValueType = typename TBase::value_type;
				if(!is_array_type(type)) {
					if constexpr(ENABLE_EXCEPTIONS)
						throw InvalidUsageError {"Attempted to assign vector to non-array property (of type " + std::string {magic_enum::enum_name(type)} + "), this is not allowed!"};
					else
						return false;
				}
				auto valueType = type_to_enum<TValueType>();
				auto size = v.size();
				auto &a = *static_cast<Array *>(value);
				a.Clear();
				a.SetValueType(valueType);
				a.Resize(size);

				if(size_of_base_type(valueType) != sizeof(typename TBase::value_type)) {
					if constexpr(ENABLE_EXCEPTIONS)
						throw InvalidUsageError {"Type size mismatch!"};
					else
						return false;
				}
				auto vs = [this, &a, &v](auto tag) {
					using TTag = typename decltype(tag)::type;
					memcpy(a.GetValues(), v.data(), v.size() * sizeof(v[0]));
				};
				if(is_ng_type(valueType))
					visit_ng(valueType, vs);
				else if(is_non_trivial_type(valueType)) {
					// Elements have to be copied explicitly
					for(auto i = decltype(size) {0u}; i < size; ++i)
						a[i] = v[i];
				}
				else
					return false;
				return true;
			}
			else if constexpr(pragma::util::is_specialization<TBase, std::unordered_map>::value || pragma::util::is_specialization<TBase, std::map>::value) {
				if(type != Type::Element) {
					if constexpr(ENABLE_EXCEPTIONS)
						throw InvalidUsageError {"Attempted to assign map to non-element property (of type " + std::string {magic_enum::enum_name(type)} + "), this is not allowed!"};
					else
						return false;
				}
				for(auto &pair : v)
					(*this)[pair.first] = pair.second;
				return true;
			}
			auto vType = type_to_enum_s<TBase>();
			if(vType == Type::Invalid) {
				if constexpr(ENABLE_EXCEPTIONS)
					throw LogicError {"Attempted to assign value of type '" + std::string {typeid(T).name()} + "', which is not a recognized type!"};
				else
					return false;
			}
			auto vs = [this, &v](auto tag) {
				using TTag = typename decltype(tag)::type;
				if constexpr(is_convertible<TBase, TTag>()) {
					*static_cast<TTag *>(value) = convert<TBase, TTag>(v);
					return true;
				}
				else
					return false;
			};
			return visit(vType, vs);
		}

		template<typename T>
		void Property::operator=(T &&v)
		{
			Assign<true, T>(std::forward<T>(v));
		}

		template<typename T>
		PProperty Property::Create(T &&value)
		{
			auto prop = Create<T>();
			*prop = value;
			return prop;
		}

		template<typename T>
		void Property::Construct(Property &prop, T &&value)
		{
			prop = value;
		}

		template<typename T>
		PProperty Property::Create()
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			return Create(type_to_enum<TBase>());
		}

		template<typename T>
		void Property::Construct(Property &prop)
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			Construct(prop, type_to_enum<TBase>());
		}

		template<typename T>
		uint64_t Property::WriteBlockSize(IFile &f)
		{
			auto offsetToSize = f.Tell();
			f.Write<T>(0);
			return offsetToSize;
		}
		template<typename T>
		void Property::WriteBlockSize(IFile &f, uint64_t offset)
		{
			auto startOffset = offset + sizeof(T);
			auto curOffset = f.Tell();
			f.Seek(offset);
			f.Write<T>(curOffset - startOffset);
			f.Seek(curOffset);
		}

		template<typename T>
		void Property::NumericTypeToString(T value, std::stringstream &ss)
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			if constexpr(std::is_same_v<TBase, Half>) {
				NumericTypeToString<float>(value, ss);
				return;
			}
			if constexpr(!std::is_floating_point_v<T>) {
				if constexpr(std::is_same_v<T, Int8> || std::is_same_v<T, UInt8>)
					ss << +value;
				else
					ss << value;
				return;
			}
			// SetAppropriatePrecision(ss,type_to_enum<T>());
			ss << NumericTypeToString(value);
		}
		template<typename T>
		std::string Property::NumericTypeToString(T value)
		{
			using TBase = std::remove_cv_t<std::remove_reference_t<T>>;
			if constexpr(std::is_same_v<TBase, Half>)
				return NumericTypeToString<float>(value);
			if constexpr(!std::is_floating_point_v<T>) {
				if constexpr(std::is_same_v<T, Int8> || std::is_same_v<T, UInt8>)
					return std::to_string(+value);
				return std::to_string(value);
			}
			// TODO: This is not very efficient...
			// (We need a temporary stringstream because we want to
			// remove trailing zeroes)
			std::stringstream tmp;
			SetAppropriatePrecision(tmp, type_to_enum<T>());
			if constexpr(std::is_same_v<T, Int8> || std::is_same_v<T, UInt8>)
				tmp << +value;
			else
				tmp << value;
			auto str = tmp.str();
			RemoveTrailingZeroes(str);
			return str;
		}

		template<typename T>
		T &Property::GetValue()
		{
			return GetValue<T>(type_to_enum<T>());
		}

		template<typename T>
		const T &Property::GetValue() const
		{
			return const_cast<Property *>(this)->GetValue<T>();
		}
		template<typename T>
		T Property::ToValue(const T &defaultValue) const
		{
			if(!this) // This can happen in chained expressions. TODO: This is technically undefined behavior and should be implemented differently!
				return defaultValue;
			auto val = ToValue<T>();
			return val.has_value() ? *val : defaultValue;
		}
		template<typename T>
		std::optional<T> Property::ToValue() const
		{
			if(!this) // This can happen in chained expressions. TODO: This is technically undefined behavior and should be implemented differently!
				return {};
			if constexpr(pragma::util::is_specialization<T, std::vector>::value) {
				T v {};
				auto res = GetBlobData(v);
				return (res == BlobResult::Success) ? v : std::optional<T> {};
			}
			else if constexpr(pragma::util::is_specialization<T, std::unordered_map>::value || pragma::util::is_specialization<T, std::map>::value) {
				if(type != Type::Element)
					return {};
				using TValue = decltype(T::value_type::second);
				auto &e = GetValue<Element>();
				T result {};
				for(auto &pair : e.children) {
					auto val = pair.second->ToValue<TValue>();
					if(val.has_value() == false)
						continue;
					result[pair.first] = std::move(val.value());
				}
				return result;
			}
			auto vs = [&](auto tag) -> std::optional<T> {
				if constexpr(is_convertible<typename decltype(tag)::type, T>())
					return convert<typename decltype(tag)::type, T>(const_cast<Property *>(this)->GetValue<typename decltype(tag)::type>());
				return {};
			};
			return visit(type, vs);
			static_assert(pragma::math::to_integral(Type::Count) == 36, "Update this list when new types are added!");
			return {};
		}

		template<typename T>
		T &Property::GetValue(Type type)
		{
			assert(value && this->type == type);
			if(this->type != type && !(this->type == Type::ArrayLz4 && type == Type::Array))
				throw LogicError {"Type mismatch, requested type is " + std::string {magic_enum::enum_name(type)} + ", but actual type is " + std::string {magic_enum::enum_name(this->type)} + "!"};
			return *GetValuePtr<T>();
		}

		template<typename T>
		T *Property::GetValuePtr()
		{
			// TODO: this should never be null, but there are certain cases where it seems to happen
			if(!this)
				return nullptr;
			if constexpr(std::is_same_v<T, Array>)
				return is_array_type(this->type) ? reinterpret_cast<T *>(value) : nullptr;
			return (this->type == type_to_enum<T>()) ? reinterpret_cast<T *>(value) : nullptr;
		}

		template<class T>
		BlobResult Property::GetBlobData(T &v) const
		{
			if(!*this)
				return BlobResult::InvalidProperty;
			uint64_t reqBufferSize = 0;
			auto result = GetBlobData(v.data(), v.size() * sizeof(v[0]), &reqBufferSize);
			if(result == BlobResult::InsufficientSize) {
				if(v.size() * sizeof(v[0]) != reqBufferSize) {
					if((reqBufferSize % sizeof(v[0])) > 0)
						return BlobResult::ValueTypeMismatch;
					v.resize(reqBufferSize / sizeof(v[0]));
					return GetBlobData<T>(v);
				}
				return result;
			}
			if(result != BlobResult::NotABlobType)
				return result;
			if constexpr(is_trivial_type(type_to_enum_s<typename T::value_type>())) {
				if(is_array_type(this->type)) {
					auto &a = GetValue<Array>();
					if(a.GetValueType() == type_to_enum<typename T::value_type>()) {
						v.resize(a.GetSize());
						memcpy(v.data(), a.GetValues(), v.size() * sizeof(v[0]));
						return BlobResult::Success;
					}
				}
			}
			return BlobResult::NotABlobType;
		}
	}
}

// --- END PARTITION: src/interface/property.cppm ---

// --- BEGIN PARTITION: src/interface/data.cppm ---
/*
// SPDX-FileCopyrightText: © 2021 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

#include "definitions.hpp"

export module pragma.udm:data;

export import :core;
export import :enums;
export import :file;
import :property;
export import :types;
*/

// --- START BODY: src/interface/data.cppm ---

export {
	namespace udm {
		class DLLUDM Data {
		  public:
			static constexpr auto KEY_ASSET_TYPE = "assetType";
			static constexpr auto KEY_ASSET_VERSION = "assetVersion";
			static constexpr auto KEY_ASSET_DATA = "assetData";
			static std::optional<FormatType> GetFormatType(const std::string &fileName, std::string &outErr);
			static std::optional<FormatType> GetFormatType(std::unique_ptr<IFile> &&f, std::string &outErr);
			static std::optional<FormatType> GetFormatType(const pragma::filesystem::VFilePtr &f, std::string &outErr);
			static std::shared_ptr<Data> Load(const std::string &fileName);
			static std::shared_ptr<Data> Load(std::unique_ptr<IFile> &&f);
			static std::shared_ptr<Data> Load(const pragma::filesystem::VFilePtr &f);
			static std::shared_ptr<Data> Open(const std::string &fileName);
			static std::shared_ptr<Data> Open(std::unique_ptr<IFile> &&f);
			static std::shared_ptr<Data> Open(const pragma::filesystem::VFilePtr &f);
			static std::shared_ptr<Data> Create(const std::string &assetType, Version assetVersion);
			static std::shared_ptr<Data> Create();
			static bool DebugTest();

			PProperty LoadProperty(const std::string_view &path) const;
			void ResolveReferences();

			bool Save(const std::string &fileName) const;
			bool Save(IFile &f) const;
			bool Save(const pragma::filesystem::VFilePtr &f);
			bool SaveAscii(const std::string &fileName, AsciiSaveFlags flags = AsciiSaveFlags::Default) const;
			bool SaveAscii(IFile &f, AsciiSaveFlags flags = AsciiSaveFlags::Default) const;
			bool SaveAscii(const pragma::filesystem::VFilePtr &f, AsciiSaveFlags flags = AsciiSaveFlags::Default) const;
			Element &GetRootElement() { return *static_cast<Element *>(m_rootProperty->value); }
			const Element &GetRootElement() const { return const_cast<Data *>(this)->GetRootElement(); }
			AssetData GetAssetData() const;

			bool operator==(const Data &other) const;
			bool operator!=(const Data &other) const { return !operator==(other); }

			LinkedPropertyWrapper operator[](const std::string &key) const;
			Element *operator->();
			const Element *operator->() const;
			Element &operator*();
			const Element &operator*() const;

			std::string GetAssetType() const;
			Version GetAssetVersion() const;
			void SetAssetType(const std::string &assetType);
			void SetAssetVersion(Version version);

			void ToAscii(std::stringstream &ss, AsciiSaveFlags flags = AsciiSaveFlags::Default) const;

			const Header &GetHeader() const { return m_header; }

			static std::string ReadKey(IFile &f);
			static void WriteKey(IFile &f, const std::string &key);
		  private:
			friend AsciiReader;
			friend ArrayLz4;
			bool ValidateHeaderProperties();
			static void SkipProperty(IFile &f, Type type);
			PProperty LoadProperty(Type type, const std::string_view &path) const;
			static PProperty ReadProperty(IFile &f);
			static void WriteProperty(IFile &f, const Property &o);
			Data() = default;
			Header m_header;
			std::unique_ptr<IFile> m_file = nullptr;
			PProperty m_rootProperty = nullptr;
		};
	}
}

// --- END PARTITION: src/interface/data.cppm ---

// --- BEGIN PARTITION: src/interface/wrapper_funcs_impl.cppm ---
/*
// SPDX-FileCopyrightText: © 2025 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm:wrapper_funcs_impl;

import :property;
import :types.string;
import :wrapper_funcs;
*/

// --- START BODY: src/interface/wrapper_funcs_impl.cppm ---

export {
	// Utility functions to prevent circular dependencies
	template<typename T>
	udm::PProperty udm::create_property(T &&value)
	{
		return Property::Create<T>(std::forward<T>(value));
	}
	udm::PProperty udm::copy_property(const Property &prop) { return std::make_shared<Property>(prop); }
	udm::Type udm::get_property_type(const Property &prop) { return prop.type; }

	udm::Type udm::get_property_type(const PropertyWrapper &prop) { return prop->type; }
	bool udm::is_property_type(const Property &prop, Type type) { return prop.IsType(type); }
	udm::DataValue udm::get_property_value(Property &prop) { return prop.value; }
	udm::DataValue udm::get_property_value(PropertyWrapper &prop) { return prop->value; }
	template<typename T>
	T &udm::get_property_value(Property &prop)
	{
		return prop.GetValue<T>();
	}
	template<typename T>
	T &udm::get_property_value(PropertyWrapper &prop)
	{
		return prop.GetValue<T>();
	}
	template<typename T>
	T *udm::get_property_value_ptr(Property &prop)
	{
		return prop.GetValuePtr<T>();
	}
	template<typename T>
	std::optional<T> udm::to_property_value(Property &prop)
	{
		return prop.ToValue<T>();
	}
	template<typename T>
	    requires(!udm::is_struct_type<T>)
	void udm::set_property_value(Property &prop, T &&value)
	{
		prop = std::forward<T>(value);
	}
	template<class T>
	udm::BlobResult udm::get_property_blob_data(Property &prop, T &v)
	{
		return prop.GetBlobData<T>(v);
	}

	udm::Type udm::get_array_value_type(const Array &a) { return a.GetValueType(); }
	uint16_t udm::get_array_structured_data_info_data_size_requirement(Array &a) { return a.GetStructuredDataInfo()->GetDataSizeRequirement(); }
	template<typename T>
	T &udm::get_array_value(Array &a, uint32_t idx)
	{
		return a.GetValue<T>(idx);
	}
	template<typename T>
	T *udm::get_array_value_ptr(Array &a, uint32_t idx)
	{
		return a.GetValuePtr<T>(idx);
	}
	template<typename T>
	    requires(!udm::is_struct_type<T>)
	void udm::set_array_value(Array &a, uint32_t idx, T &&v)
	{
		a.SetValue<T>(idx, std::forward<T>(v));
	}
	uint32_t udm::get_array_value_size(const Array &a) { return a.GetValueSize(); }
	uint32_t udm::get_array_size(const Array &a) { return a.GetSize(); }
	void *udm::get_array_values(Array &a) { return a.GetValues(); }
	bool udm::is_array_value_type(const Array &a, Type pvalueType) { return a.IsValueType(pvalueType); }

	template<typename T>
	void udm::get_array_begin_iterator(Array &a, ArrayIterator<T> &outIt)
	{
		outIt = a.begin<T>();
	}
	template<typename T>
	void udm::get_array_end_iterator(Array &a, ArrayIterator<T> &outIt)
	{
		outIt = a.end<T>();
	}

	udm::PProperty *udm::find_element_child(Element &e, const std::string_view &key)
	{
		auto it = e.children.find(key);
		if(it == e.children.end())
			return nullptr;
		return &it->second;
	}
	void udm::remove_element_child(Element &e, const std::string_view &key)
	{
		auto it = e.children.find(key);
		if(it == e.children.end())
			return;
		e.children.erase(it);
	}
	void udm::erase_element_child(Element &e, Element &child) { e.EraseValue(child); }
	void udm::set_element_child_value(Element &e, const std::string_view &key, const PProperty &prop) { e.children[std::string {key}] = prop; }
	template<typename T>
	void udm::set_element_value(Element &parent, Element &child, T &&v)
	{
		parent.SetValue(child, std::forward<T>(v));
	}
	udm::PropertyWrapper &udm::get_element_parent_property(Element &e) { return e.parentProperty; }

	void udm::set_struct_value(Struct &strct, const void *inData, size_t inSize) { strct.Assign(inData, inSize); }

	// The code below will force-instantiate the template functions for all UDM types
	namespace udm::impl {
		// export to prevent the function from being optimized away
#ifdef __linux__
		__attribute__((visibility("default")))
#else
		__declspec(dllexport)
#endif
		void instantiate()
		{
			visit(Type {}, [](auto tag) {
				using T = typename decltype(tag)::type;
				auto &v = *static_cast<T *>(nullptr);

				udm::set_array_value<T>(*static_cast<Array *>(nullptr), 0, std::forward<T>(v));
				udm::set_array_value<T &>(*static_cast<Array *>(nullptr), 0, std::forward<T &>(v));
				udm::set_array_value<const T &>(*static_cast<Array *>(nullptr), 0, std::forward<const T &>(v));

				udm::create_property<T>(std::forward<T>(v));

				if constexpr(!std::is_same_v<T, Boolean> && !std::is_same_v<T, Blob> && !std::is_same_v<T, BlobLz4> && !std::is_same_v<T, UInt8>) {
					std::vector<T> &vec = *static_cast<std::vector<T> *>(nullptr);
					udm::create_property<std::vector<T>>({});
					udm::create_property<std::vector<T> &>(vec);
					udm::create_property<const std::vector<T> &>(vec);

					udm::set_property_value<std::vector<T>>(*static_cast<Property *>(nullptr), {});
					udm::set_property_value<std::vector<T> &>(*static_cast<Property *>(nullptr), vec);
					udm::set_property_value<const std::vector<T> &>(*static_cast<Property *>(nullptr), vec);
				}

				if constexpr(!std::is_same_v<T, Boolean> && !std::is_same_v<T, Array> && !std::is_same_v<T, ArrayLz4> && !std::is_same_v<T, Element>) {
					udm::to_property_value<std::vector<T>>(*static_cast<Property *>(nullptr));

					std::vector<T> blobData;
					udm::get_property_blob_data(*static_cast<Property *>(nullptr), blobData);
				}

				if constexpr(!std::is_same_v<T, Boolean> && !std::is_same_v<T, UInt8>) {
					std::vector<T> &vec = *static_cast<std::vector<T> *>(nullptr);
					udm::set_element_value<std::vector<T>>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), {});
					udm::set_element_value<std::vector<T> &>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), vec);
					udm::set_element_value<const std::vector<T> &>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), vec);
				}

				if constexpr(!std::is_same_v<T, UInt8> && !std::is_same_v<T, Array> && !std::is_same_v<T, ArrayLz4> && !std::is_same_v<T, Element>) {
					std::vector<T> &vec = *static_cast<std::vector<T> *>(nullptr);
					udm::set_array_value<std::vector<T>>(*static_cast<Array *>(nullptr), 0u, {});
					udm::set_array_value<std::vector<T> &>(*static_cast<Array *>(nullptr), 0u, vec);
					udm::set_array_value<const std::vector<T> &>(*static_cast<Array *>(nullptr), 0u, vec);
				}

				udm::get_property_value<T>(*static_cast<Property *>(nullptr));
				udm::get_property_value<T>(*static_cast<PropertyWrapper *>(nullptr));
				udm::get_property_value_ptr<T>(*static_cast<Property *>(nullptr));
				udm::to_property_value<T>(*static_cast<Property *>(nullptr));
				udm::set_property_value(*static_cast<Property *>(nullptr), v);

				udm::get_array_value<T>(*static_cast<Array *>(nullptr), 0u);
				udm::get_array_value_ptr<T>(*static_cast<Array *>(nullptr), 0u);
				udm::set_array_value<T>(*static_cast<Array *>(nullptr), 0u, std::forward<T>(v));
				udm::get_array_begin_iterator<T>(*static_cast<Array *>(nullptr), *static_cast<ArrayIterator<T> *>(nullptr));
				udm::get_array_end_iterator<T>(*static_cast<Array *>(nullptr), *static_cast<ArrayIterator<T> *>(nullptr));

				udm::set_element_value<T>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), std::forward<T>(v));

				udm::set_element_value<const T &>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), std::forward<const T &>(v));
				udm::set_element_value<T &>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), std::forward<T &>(v));
				udm::set_property_value<const T &>(*static_cast<Property *>(nullptr), std::forward<const T &>(v));
			});
			udm::get_array_begin_iterator<LinkedPropertyWrapper>(*static_cast<Array *>(nullptr), *static_cast<ArrayIterator<LinkedPropertyWrapper> *>(nullptr));
			udm::get_array_end_iterator<LinkedPropertyWrapper>(*static_cast<Array *>(nullptr), *static_cast<ArrayIterator<LinkedPropertyWrapper> *>(nullptr));

			udm::create_property<std::string_view>({});
			udm::set_property_value<std::string_view>(*static_cast<Property *>(nullptr), {});
			udm::set_array_value<std::string_view>(*static_cast<Array *>(nullptr), 0u, {});
			udm::set_element_value<std::string_view>(*static_cast<Element *>(nullptr), *static_cast<Element *>(nullptr), {});

			auto &prop = *static_cast<PProperty *>(nullptr);
			udm::set_property_value<PProperty>(*static_cast<Property *>(nullptr), {});
			udm::set_property_value<PProperty &>(*static_cast<Property *>(nullptr), prop);
			udm::set_property_value<const PProperty &>(*static_cast<Property *>(nullptr), prop);
		}
	}
}

// --- END PARTITION: src/interface/wrapper_funcs_impl.cppm ---

// --- BEGIN PARTITION: src/interface/udm.cppm ---
/*
// SPDX-FileCopyrightText: (c) 2025 Silverlan <opensource@pragma-engine.com>
// SPDX-License-Identifier: MIT

module;

export module pragma.udm;
export import :array;
export import :array_iterator;
export import :asset_data;
export import :basic_types;
export import :types.blob;
export import :conversion;
export import :core;
export import :data;
export import :types.element;
export import :enums;
export import :exception;
export import :file;
export import :half;
export import :property;
export import :property_wrapper;
export import :reference;
export import :types.string;
export import :structure;
export import :trivial_types;
export import :types;
export import :util;
export import :wrapper_funcs;
export import :wrapper_funcs_impl;
*/

// --- START BODY: src/interface/udm.cppm ---
// (no body found in original file)

// --- END PARTITION: src/interface/udm.cppm ---

